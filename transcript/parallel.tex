\chapter{ Parallel Packrat Parsing }
\label{ch:parallel}

Η βασική συνεισφορά που θέλουμε να κάνουμε στα πλαίσια της διπλωματικής, είναι να τροποποιήσουμε τη σειριακή έκδοση του packrat parser, ώστε να μπορεί να τρέξει αποδοτικότερα σε ένα πολυπύρηνο σύστημα.
Επιπλέον, θα δοκιμάσουμε τα παραλληλοποιήσουμε όχι μόνο την κλασική έκδοση του packrat, αλλά και παραλλαγών της.

To πρόβλημα εύρεσης παραλληλισμού δεν είναι καθόλου τετριμμένο εν γένει. 
Ειδικά στην περίπτωση μας, θα πρέπει να εξετάσουμε διάφορα κομμάτια του αλγορίθμου που μπορούν να μοιραστούν μεταξύ των νημάτων, καθώς και πώς τα νήματα αυτά θα προσπελάσουν τη δομή δεδομένων με τα ενδιάμεσα αποτελέσματα.
Εδώ, πρέπει να προσέξουμε ιδιαιτέρως δύο σημεία:

\begin{description}[font=$\bullet$\scshape\bfseries]
	\item Η πρόσβαση σε κάθε κελί της δομής δεδομένων πρέπει να γίνεται με \textit{αμοιβαίο αποκλεισμό (mutual exlusion)} μεταξύ των νημάτων.
	\item Θέλουμε η \textit{αναμονή (waiting)} των νημάτων να είναι όσο το δυνατόν μικρότερη.
\end{description}

Θα ξεκινήσουμε πρώτα με τον αλγόριθμο δυναμικού προγραμματισμού για το packrat parsing (DP packrat).
Ακολούθως, θα επικεντρωθούμε στον αλγόριθμο με υπομνηματισμό.
Θα δούμε τί έχει δοκιμαστεί ως τώρα από την επιστημονική κοινότητα, ενώ θα επιχειρήσουμε και δικές μας προσεγγίσεις.

\section{Παράλληλος DP packrat}

Η εκδοχή με τον από κάτω προς τα κάτω αναλυτή, μπορεί να παραλληλοποιηθεί εύκολα (embarassingly parallel). 
Αναθέτοντας σε κάθε νήμα από μία στήλη του πίνακα για υπολογίσει, μπορούμε να σπάσουμε εύκολα το αρχικό πρόβλημα σε επιμέρους υποπροβλήματα.

\definecolor{Gray}{gray}{0.8}
\newcolumntype{g}{>{\columncolor{Gray}}c}
\begin{table}[ht]
\begin{center}
  \begin{tabular}{|c|c|c|g|g|g|g|c|c|}
    \hline
     & & & & & & & &  \\ \hline \hline
     & & & & & & & &  \\ \hline \hline
     & & & & & & & &  \\ \hline \hline
     & & & & & & & &  \\ \hline
  \end{tabular}
\end{center}
\caption{Παραλληλοποίηση ανοδικού Packrat Parser}
    \label{tab:bottom_up}
\end{table}

\newcolumntype{g}{>{\columncolor{Gray}}c}
\begin{table}[ht]
\centering
\begin{tabular}{|c|c|c|g|g|g|g|c|c|c|c|}
\hline
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\ \hline
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\ \hline
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\ \hline
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\ \hline
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\ \hline
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\ 
\hline
	& 	& 	&thr4 &thr3 & thr2 &thr1 & & & & \\ \hline
\end{tabular}
\end{table}

Βέβαια, δεν αναμένουμε να είναι γραμμική η επιτάχυνση του αλγορίθμου καθώς τα αποτελέσματα της στήλης ενός νήματος μπορεί να εξαρτώνται από τις τιμές των κελιών που βρίσκονται στις στήλες άλλων νημάτων.
Έτσι, ένα νήμα θα πρέπει να κάνει τη "δουλειά" κάποιου άλλου νήματος, οπότε ο φόρτος δεν μοιράζεται εξίσου.

Όπως και να 'χει, με δεδομένο ότι το παράλληλος DP Packrat είναι πολύ αργός στη σειριακή περίπτωση, καθώς υπολογίζονται πολλά κελιά του πίνακα που δεν χρειάζονται, επικεντρωνόμαστε εφεξής στον καθοδικό packrat parser και τις παραλλαγές του.

\section{Παράλληλο Καθοδικό Packrat Parsing}

Η πρώτη ιδέα στη βελτίωση της απόδοσης του καθοδικού Packrat Parser είναι να προσπαθήσουμε να βρούμε κάποιο κομμάτι του αλγορίθμου το οποίο μπορεί να εκτελεστεί από πολλά νήματα ταυτόχρονα, ώστε να μοιραστεί ο φόρτος εργασίας.
Έτσι, το κομμάτι αυτό του αλγορίθμου θα μπορεί να εκτελεστεί ταχύτερα, οδηγώντας και σε ταχύτερη εκτέλεση συνολικά.

Επαναλαμβάνουμε ότι ο αναλυτής μας "επισκέπτεται" κάθε στοιχείο της γραμματικής για να την αναλύσει.
Αρχικά, θα πάει στο αρχικό μη τερματικό της γραμματικής. 
Ακολούθως, θα πάει στη σύνθετη έκφραση που αντιστοιχεί σε αυτό το μη τερματικό.
Μία ιδέα θα ήταν να προσπαθήσουμε να παραλληλοποιήσουμε τη συντακτική ανάλυση των σύνθετων εκφράσεων.

Προφανώς, για μία ακολουθία από εκφράσεις:

\begin{equation}
	E \leftarrow E_1 E_2 E_3
\end{equation}

θα ήταν δύσκολο να αναθέσουμε μία υποέκφραση $E_i$ σε κάθε νήμα, καθώς πρέπει πρώτα να προσπαθήσουμε να αναλύσουμε την $E_1$ και, αν πετύχει, να αναλύσουμε την $E_2$ συνεχίζοντας από το σημείο της εισόδου που μας άφησε η $E_1$. 
Επειδή, δεν ξέρουμε εκ των προτέρων ποιο θα είναι αυτό, δεν μπορούμε έτσι απλά να δώσουμε την $E_2$ να την υπολογίσει άλλο νήμα.

Ωστόσο, στη διατεταγμένη ακολουθία:

\begin{equation}
	E \leftarrow E_1 / E_2 /  E_3
\end{equation}

οι υποεκφράσεις αναλύονται ξεκινώντας από το ίδιο σημείο της εισόδου (αν αποτύχει η $E_1$, τότε ξαναπροσπαθεί από το ίδιο σημείο η $E_2$ κλπ).
Θεωρητικά, λοιπόν, θα μπορούσαμε να τις αναθέσουμε σε ξεχωριστά νήματα.
Εδώ, όμως, χρειάζεται προσοχή.
Αν το νήμα που αναλύσει την $E_2$, επιστρέψει επιτυχώς, πρέπει πάλι να περιμένουμε το νήμα που αναλύει την $E_1$, καθώς η υποέκφραση αυτή έχει προτεραιότητα.

Συνεπώς, η κύρια διεργασία που έχει αναλάβει την ανάλυση της έκφρασης $E$ θα πρέπει να καλέσει ξεχωριστά νήματα-εργάτες για κάθε υποέκφραση, αλλά να τηρήσει την ιεραρχία:

\begin{description}[font=$\bullet$\scshape\bfseries]
	\item Πρώτα περιμένει να ολοκληρώσει το νήμα της $E_1$.
	\item Αν επιτύχει, τότε στέλνει σήμα στα υπόλοιπα νήματα να επιστρέψουν.
	\item Αλλιώς, περιμένει να τελειώσει το δεύτερο νήμα.
	\item Η διαδικασία συνεχίζεται μέχρις ότου κάποιο νήμα επιστρέψει επιτυχώς (οπότε τερματίζονται τα 
			επόμενα στην ιεραρχία, είτε αν επιστρέψουν όλα τα νήματα ανεπιτυχώς. % TODO: fix indent
\end{description}

Αν όλα επιστρέψουν ανεπιτυχώς, τότε και το κύριο νήμα που τα κάλεσε επιστρέφει ανεπιτυχώς και θέτει τη θέση στην είσοδο, όπως ήταν στην αρχή (reset).
Αλλιώς, το πρώτο νήμα στην ιεραρχία που πέτυχε καθορίζει και από ποιο σημείο της εισόδου θα συνεχίσει η ανάλυση.

Ενδεικτικά, ο κώδικας που θα υλοποιούσε κάτι τέτοιο φαίνεται στην Σχήμα \ref{fig:top_down_1}.

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
    finished_rank.store(-1);

    auto i = 0;
    for (auto& expr : exprs) { 
        workers.emplace_back(new SimpleWorker(in, peg, cells, pos, i));
        threads.emplace_back([&, expr, i, this]()
            {
                results.push_back(expr->accept(*workers[i]));
                positions.push_back((*workers[i]).cur_pos());
            }
        );
        i++;
    }

    auto j = 0;
    for (auto w : workers) {
        threads[j].join(); 
        delete workers[j];
        if (results[j]) { 
            finished_rank.store(j);
            pos = positions[j];
            for (auto k = j + 1; k < workers.size(); ++k) {
                threads[k].join();
                delete workers[k];
            }
            return true;
        }
        j++;
    }
    pos = orig_pos;
    return false;
\end{minted}
\caption{Δημιουργία και τερματισμός νημάτων με βάση την ιεραρχία για κάθε υποέκφραση}
\label{fig:top_down_1}
\end{figure}

Για να έχει νόημα η παραπάνω παραλληλοποίηση πρέπει να διασφαλίζουμε ότι όταν ένα νήμα επιστρέφει επιτυχώς, τα επόμενα στην ιεραρχία θα τερματίζονται όσο το δυνατόν γρηγορότερα.
Για το σκοπό αυτό, υπάρχει μία καθολική μεταβλητή $finished\_rank$, η οποία κρατάει το νούμερο του νήματος που ολοκλήρωσε επιτυχώς, αρκεί να μην υπάρχουν νήματα πιο πάνω στην ιεραρχία που επίσης έχουν επιστρέψει επιτυχώς.
Για λόγους συγχρονισμού, η μεταβλητή αυτή είναι ατομική.
Στην αρχή τίθεται ως $-1$ από το κύριο νήμα.

Θεωρούμε ότι κάθε νήμα-εργάτης έχει ένα μοναδικό νούμερο $rank$, όπου ψηλότερα στην ιεραρχία είναι το νούμερο $0$.
Άρα, σε κάθε αναδρομική κλήση που κάνει το νήμα-εργάτης προτού επισκεφθεί κάθε έκφραση, κάνει τον έλεγχο του Σχήματος \ref{fig:top_down_2} για πρόωρο τερματισμό.

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
    auto fr = finished_rank.load();
    if (fr >= 0 && fr < rank) { 
        std::cout << "rank: " << rank << std::endl;
        return false;
    }
\end{minted}
\caption{Έλεγχος της καθολικής μεταβλητής για πρόωρο τερματισμό}
\label{fig:top_down_2}
\end{figure}

Αντίστοιχα, αν το νήμα-εργάτης πρόκειται να επιστρέψει επιτυχώς πρέπει να επιχειρήσει να θέσει την καθολική μεταβλητή με το δικό του αριθμό (rank), όπως φαίνεται στο Σχήμα \ref{fig:top_down_3}.

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
    auto fr = finished_rank.load();
    if (fr < 0 || fr > rank) { 
        finished_rank.store(rank);
    }
\end{minted}
\caption{Έλεγχος της καθολικής μεταβλητής για ενεργοποίησή της με το βαθμό του νήματος-εργάτη}
\label{fig:top_down_3}
\end{figure}

%\begin{minipage}{\textwidth} TODO

Βέβαια, θα υπάρχουν και περιπτώσεις όπου η διατεταγμένη επιλογή θα περιλαμβάνει πολλές εναλλακτικές, ιδιαίτερα στα μη τερματικά που αφορούν τη λεκτική ανάλυση του προγράμματος, όπως φαίνεται στην Σχήμα \ref{fig:top_down_4}

\begin{figure}[h]
\begin{Verbatim}
HexDigit <- 'a' / 'b' / 'c' / 'd' / 'e' / 'f' / 
    'A' / 'B' / 'C' / 'D' / 'E' / 'F' / Digit
\end{Verbatim}
\caption{Κανόνας με πολλές εναλλακτικές στη διατεταγμένη επιλογή}
\label{fig:top_down_4}
\end{figure}

%\end{minipage}

Συνήθως, όταν υπάρχουν πολλές εναλλακτικές στη διατεταγμένη επιλογή, αυτές αποτελούν τερματικά (κυρίως για τους κανόνες που αφορούν λεκτική ανάλυση), τα οποία μπορούν να αναλυθούν άμεσα. 
Στην περίπτωση αυτή, μάλλον δεν είναι συμφέρον για το κύριο νήμα να καλέσει ένα νήμα για την ανάλυση της κάθε υποέκφρασης, καθώς το κόστος τόσο της κλήσης πολλών νημάτων, όσο και της αναμονής να τελειώσουν (join) θα είναι μεγάλο.
Τότε, συμφέρει καλύτερα το κύριο νήμα να αναλύσει τη διατεταγμένη επιλογή μόνο του, παρά να καλέσει άλλα νήματα-εργάτες. 
Ο κώδικας φαίνεται στο ΣΧήμα \ref{fig:expr_size}.

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
if (exprs.size() > size_limit) {    // Parse without spawning threads
    for (auto expr : exprs) {
        pos = orig_pos;
        if (expr->accept(*this))
            return true;
    }
    pos = orig_pos;
    return false;
}
\end{minted}
\caption{Έλεγχος για την εκτέλεση ή μη της διατεταγμένης επιλογής με βάση το μέγεθος}
\label{fig:expr_size}
\end{figure}

Τέλος, πρέπει να λάβουμε υπόψη ότι, πλέον, ο πίνακας υπομνηματισμού προσπελάζεται και τροποποιείται παράλληλα (concurrently).
Επομένως, μία λύση είναι κάθε κελί να έχει ένα ξεχωριστό κλείδωμα (lock), το οποίο να δεσμεύεται όταν θέλουμε να το προσπελάζουμε. %TODO

\section{Παράλληλο Elastic Packrat Parsing}

Οι ιδέες που περιγράψαμε παραπάνω για την παραλληλοποίηση του κλασσικού αλγορίθμου packrat, εφαρμόζονται άμεσα και στο elastic packrat parsing με ελάχιστες τροποποιήσεις.
Όπως περιγράψαμε σε προηγούμενο κεφάλαιο, το elastic packrat parsing διαφέρει με τον κλασσικό αλγόριθμο στον τρόπο με τον οποίο αποθηκεύονται τα δεδομένα. 
Συγκεκριμένα, αντί για δισδιάστατο πίνακα, κρατάει έναν μονοδιάστατο μικρότερου μεγέθους στον οποίο αντιστοιχίζονται ζεύγη $(position, non terminal)$, όπου non terminal είναι ένα ενεργοποιμένο μη τερματικό.
Οπότε, και πάλι κάθε στοιχείο του πίνακα έχει ένα κλείδωμα το οποίο αποτρέπει τις συνθήκες ανταγωνισμού για το κελί.

Επιπλέον, ακολουθούμε και μία ακόμη προσέγγιση όπου αντί να χρησιμοποιήσουμε τον μονοδιάστατο πίνακα, με ρητή δημιουργία κλειδιού και ρητό κλείδωμα, χρησιμοποιούμε τη δομή \textit{concurrent\_hash\_map} των Threading Building Blocks της Intel.
