\chapter{ Parallel Packrat Parsing }
\label{ch:parallel}

Η βασική συνεισφορά που θέλουμε να κάνουμε στα πλαίσια της διπλωματικής, είναι να τροποποιήσουμε τη σειριακή έκδοση του packrat parser, ώστε να μπορεί να τρέξει αποδοτικότερα σε ένα πολυπύρηνο σύστημα.
Επιπλέον, θα δοκιμάσουμε τα παραλληλοποιήσουμε όχι μόνο την κλασική έκδοση του packrat, αλλά και παραλλαγών της. %TODO

To πρόβλημα εύρεσης παραλληλισμού δεν είναι καθόλου τετριμμένο εν γένει. 
Ειδικά στην περίπτωση μας, θα πρέπει να εξετάσουμε διάφορα κομμάτια του αλγορίθμου που μπορούν να μοιραστούν μεταξύ των νημάτων, καθώς και πώς τα νήματα αυτά θα προσπελάσουν τη δομή δεδομένων με τα ενδιάμεσα αποτελέσματα.
Εδώ, πρέπει να προσέξουμε ιδιαιτέρως δύο σημεία:

\begin{itemize}
	\item Η πρόσβαση σε κάθε κελί της δομής δεδομένων πρέπει να γίνεται με \textit{αμοιβαίο αποκλεισμό (mutual exlusion)} μεταξύ των νημάτων.
	\item Θέλουμε η \textit{αναμονή (waiting)} των νημάτων να είναι όσο το δυνατόν μικρότερη.
\end{itemize}

Θα ξεκινήσουμε πρώτα με τον αλγόριθμο δυναμικού προγραμματισμού για το packrat parsing (DP packrat).
Ακολούθως, θα επικεντρωθούμε στον αλγόριθμο με υπομνηματισμό.
Θα δούμε τί έχει δοκιμαστεί ως τώρα από την επιστημονική κοινότητα, ενώ θα επιχειρήσουμε και δικές μας προσεγγίσεις. % TODO

\section{Παράλληλος DP packrat}

Η εκδοχή με τον από κάτω προς τα κάτω αναλυτή, μπορεί να παραλληλοποιηθεί εύκολα (embarassingly parallel). 
Αναθέτοντας σε κάθε νήμα από μία στήλη του πίνακα για υπολογίσει, μπορούμε να σπάσουμε εύκολα το αρχικό πρόβλημα σε επιμέρους υποπροβλήματα.
Ο υπολογισμός γίνεται από κάτω προς τα πάνω, όπως φαίνεται στον Πίνακα \ref{table:dp}.

\begin{table}[]
  \centering
\begin{tabular}{|c|c|c|c|c|c|}
\hline
 &  &  &  &  & \\ \hline
 $\uparrow$& $\uparrow$ & $\uparrow$ & $\uparrow$ & $\uparrow$ & $\uparrow$ \\ \hline
 | & | & | & | & | & | \\ \hline
 | & | & | & | & | & | \\ \hline
 Thread 2 & Thread 1 & Thread 4 & Thread 3 & Thread 2 & Thread 1  \\ \hline
\end{tabular}
\caption{Μοίρασμα του υπολογισμού των κελιών για τον DP Packrat}
  \label{table:dp}
\end{table}

Βέβαια, δεν αναμένουμε να είναι γραμμική η επιτάχυνση του αλγορίθμου καθώς τα αποτελέσματα της στήλης ενός νήματος μπορεί να εξαρτώνται από τις τιμές των κελιών που βρίσκονται στις στήλες άλλων νημάτων.
Έτσι, ένα νήμα θα πρέπει να κάνει τη "δουλειά" κάποιου άλλου νήματος, οπότε ο φόρτος δεν μοιράζεται εξίσου.

Όπως και να 'χει, με δεδομένο ότι ο παράλληλος DP Packrat είναι πολύ αργός στη σειριακή περίπτωση, καθώς υπολογίζονται πολλά κελιά του πίνακα που δεν χρειάζονται, επικεντρωνόμαστε εφεξής στον καθοδικό packrat parser και τις παραλλαγές του.

\section{Παράλληλο Καθοδικό Packrat Parsing}

\subsection{Παραλληλοποίηση της Διατεταγμένης Επιλογής}

Η πρώτη ιδέα στη βελτίωση της απόδοσης του καθοδικού Packrat Parser είναι να προσπαθήσουμε να βρούμε κάποιο κομμάτι του αλγορίθμου το οποίο μπορεί να εκτελεστεί από πολλά νήματα ταυτόχρονα, ώστε να μοιραστεί ο φόρτος εργασίας.
Έτσι, αυτό το κομμάτι του αλγορίθμου θα μπορεί να εκτελεστεί ταχύτερα, οδηγώντας και σε ταχύτερη εκτέλεση συνολικά.

Επαναλαμβάνουμε ότι ο αναλυτής μας "επισκέπτεται" κάθε στοιχείο της γραμματικής για να την αναλύσει.
Πρώτα, θα πάει στο αρχικό μη τερματικό της γραμματικής. 
Ακολούθως, θα πάει στη σύνθετη έκφραση που αντιστοιχεί σε αυτό το μη τερματικό.
Μία ιδέα θα ήταν να προσπαθήσουμε να παραλληλοποιήσουμε τη συντακτική ανάλυση των σύνθετων εκφράσεων.

Προφανώς, για μία ακολουθία από εκφράσεις:

\begin{equation}
	E \leftarrow E_1 E_2 E_3
\end{equation}

θα ήταν δύσκολο να αναθέσουμε μία υποέκφραση $E_i$ σε κάθε νήμα, καθώς πρέπει πρώτα να προσπαθήσουμε να αναλύσουμε την $E_1$ και, αν πετύχει, να αναλύσουμε την $E_2$ συνεχίζοντας από το σημείο της εισόδου που μας άφησε η $E_1$. 
Επειδή, δεν ξέρουμε εκ των προτέρων ποιο θα είναι αυτό, δεν μπορούμε έτσι απλά να δώσουμε την $E_2$ να την υπολογίσει άλλο νήμα.

Ωστόσο, στη διατεταγμένη επιλογή:

\begin{equation}
	E \leftarrow E_1 / E_2 /  E_3
\end{equation}

οι υποεκφράσεις αναλύονται ξεκινώντας από το ίδιο σημείο της εισόδου (αν αποτύχει η $E_1$, τότε ξαναπροσπαθεί από το ίδιο σημείο η $E_2$ κλπ.).
Θεωρητικά, λοιπόν, θα μπορούσαμε να τις αναθέσουμε σε ξεχωριστά νήματα.

Επικεντρωνόμαστε στο Σχήμα \ref{fig:top_down_1}.

Η ανάθεση των υποεκφράσεων σε ξεχωριστά νήματα φαίνεται στις γραμμές 8-16.
Το κύριο νήμα καλεί νήματα-εργάτες για να αναλύσουν κάθε υποέκφραση χωριστά ξεκινώντας από την τρέχουσα θέση (γραμμή 11).
Μετά κρατάει για κάθε νήμα το αποτέλεσμα της συντακτικής ανάλυσης (επιτυχία ή αποτυχία) (γραμμή 12), καθώς και το επόμενο σημείο της εισόδου, εφόσον πέτυχε η ανάλυση (γραμμή 13).
Στις γραμμές 19-30 το κύριο νήμα περιμένει τα νήματα με τη σειρά να ολοκληρώσουν.

Ωστόσο, υπάρχει ένα σημείο που χρειάζεται προσοχή.
Αν το νήμα που αναλύσει την $E_2$, επιστρέψει επιτυχώς, πρέπει πάλι να περιμένουμε το νήμα που αναλύει την $E_1$, καθώς η υποέκφραση αυτή έχει προτεραιότητα.
Συνεπώς, η κύρια διεργασία που έχει αναλάβει την ανάλυση της έκφρασης $E$ θα πρέπει να καλέσει ξεχωριστά νήματα-εργάτες για κάθε υποέκφραση, αλλά να τηρήσει την ιεραρχία:

\begin{itemize}
	\item Πρώτα περιμένει να ολοκληρώσει το νήμα της $E_1$.
	\item Αν επιτύχει, τότε στέλνει σήμα στα υπόλοιπα νήματα να επιστρέψουν.
	\item Αλλιώς, περιμένει να τελειώσει το δεύτερο νήμα.
	\item Η διαδικασία συνεχίζεται είτε μέχρις ότου κάποιο νήμα επιστρέψει επιτυχώς (οπότε τερματίζονται τα 
	  επόμενα στην ιεραρχία), είτε όταν επιστρέψουν όλα τα νήματα ανεπιτυχώς. 
\end{itemize}

Αν όλα επιστρέψουν ανεπιτυχώς, τότε και το κύριο νήμα που τα κάλεσε επιστρέφει ανεπιτυχώς και θέτει το δείκτη στην είσοδο όπως ήταν στην αρχή (reset) (γρ. 31-32).
Αλλιώς, το πρώτο νήμα στην ιεραρχία που πέτυχε καθορίζει από ποιο σημείο της εισόδου θα συνεχίσει η ανάλυση (γρ. 23).

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
finished_rank.store(-1);

int results[exprs.size()];
int positions[exprs.size()];
std::vector<std::thread> threads;

auto i = 0;
for (auto& expr : exprs) { 
    threads.emplace_back([&, expr, i, this]()
    {
        SimpleWorker sw{in, peg, cells, pos, i};
        results[i] = expr->accept(sw);
        positions[i] = sw.cur_pos();
    });
    i++;
}

auto j = 0;
for (auto w : workers) {
    threads[j].join(); 
    if (results[j]) { 
        finished_rank.store(j);
        pos = positions[j];
        for (auto k = j + 1; k < workers.size(); ++k) {
            threads[k].join();
        }
        return true;
    }
    j++;
}
pos = orig_pos;
return false;
\end{minted}
\caption{Δημιουργία και τερματισμός νημάτων με βάση την ιεραρχία για κάθε υποέκφραση}
\label{fig:top_down_1}
\end{figure}

Για να έχει νόημα η παραπάνω παραλληλοποίηση πρέπει να διασφαλίζουμε ότι όταν ένα νήμα επιστρέφει επιτυχώς, τα επόμενα στην ιεραρχία θα τερματίζονται όσο το δυνατόν γρηγορότερα.
Για το σκοπό αυτό, υπάρχει μία καθολική μεταβλητή $finished\_rank$, η οποία κρατάει το νούμερο του νήματος που ολοκλήρωσε επιτυχώς, αρκεί να μην υπάρχουν νήματα πιο πάνω στην ιεραρχία που επίσης έχουν επιστρέψει επιτυχώς.
Για λόγους συγχρονισμού, η μεταβλητή αυτή είναι ατομική.
Στην αρχή τίθεται ως $-1$ από το κύριο νήμα (γρ. 1).

Θεωρούμε ότι σε κάθε νήμα-εργάτη έχει δοθεί ένα μοναδικό νούμερο $rank$, όπου ψηλότερα στην ιεραρχία είναι το νούμερο $0$ (γρ. 7, 11).
Το κύριο νήμα δίνει το $rank$ στα παιδιά του και τα περιμένει μετά ένα ένα να επιστρέψουν βάσει ιεραρχίας.
Αν κάποιο επιστρέψει επιτυχώς, το κύριο νήμα θέτει τη μεταβλητή $finished\_rank$ με το rank του νήματος (γρ. 22).

Άρα, σε κάθε αναδρομική κλήση που κάνει το νήμα-εργάτης προτού επισκεφθεί κάθε έκφραση, κάνει τον έλεγχο του Σχήματος \ref{fig:top_down_2} για πρόωρο τερματισμό.
Εάν το $finished_rank$ έχει τεθεί από νήμα μεγαλύτερης ιεραρχίας (μικρότερο $rank$), τότε το τρέχον νήμα πρέπει να επιστρέψει αμέσως (γρ. 2-3).

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
auto fr = finished_rank.load();
if (fr >= 0 && fr < rank) { 
    return false;
}
\end{minted}
\caption{Έλεγχος της καθολικής μεταβλητής για πρόωρο τερματισμό}
\label{fig:top_down_2}
\end{figure}

%\begin{minipage}{\textwidth} TODO

Βέβαια, θα υπάρχουν και περιπτώσεις όπου η διατεταγμένη επιλογή θα περιλαμβάνει πολλές εναλλακτικές, ιδιαίτερα στα μη τερματικά που αφορούν τη λεκτική ανάλυση του προγράμματος, όπως φαίνεται στο Σχήμα \ref{fig:top_down_4}.
  Το $HexDigit$ αντιπροσωπεύει τα δεκαεξαδικά ψηφία και η συντακτική ανάλυσή του ισοδυναμεί πρακτικά με την αναγνώριση της κανονικής έκφρασης $[a-fA-FDigit]$, όπου $Digit$ είναι η κανονική έκφραση για τα ψηφία.
Συνήθως, όταν υπάρχουν πολλές εναλλακτικές στη διατεταγμένη επιλογή, αυτές αποτελούν τερματικά (κυρίως για τους κανόνες που αφορούν λεκτική ανάλυση), τα οποία μπορούν να αναλυθούν άμεσα. 
Στην περίπτωση αυτή, μάλλον δεν είναι συμφέρον για το κύριο νήμα να καλέσει ένα νήμα για την ανάλυση της κάθε υποέκφρασης, καθώς το κόστος τόσο της κλήσης πολλών νημάτων, όσο και της αναμονής να τελειώσουν (join), θα είναι μεγάλο.

\begin{figure}[h]
\begin{Verbatim}


	HexDigit <- 'a' / 'b' / 'c' / 'd' / 'e' / 'f' / 
   		 'A' / 'B' / 'C' / 'D' / 'E' / 'F' / Digit
\end{Verbatim}
\caption{Κανόνας με πολλές εναλλακτικές στη διατεταγμένη επιλογή}
\label{fig:top_down_4}
\end{figure}

Τότε, συμφέρει καλύτερα το κύριο νήμα να αναλύσει τη διατεταγμένη επιλογή μόνο του, παρά να καλέσει άλλα νήματα-εργάτες. 
Ο κώδικας φαίνεται στο Σχήμα \ref{fig:expr_size}.
Το $expr\_limit$ είναι το όριο στον αριθμό των υποεκφράσεων πάνω από το οποίο δεν θα κληθούν νέα νήματα, αλλά η έκφραση θα αναλυθεί επί τόπου.

%\end{minipage}

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
if (exprs.size() > expr_limit) {    
    for (auto expr : exprs) {
        pos = orig_pos;
        if (expr->accept(*this))
            return true;
    }
    pos = orig_pos;
    return false;
}
\end{minted}
\caption{Έλεγχος για την εκτέλεση ή μη της διατεταγμένης επιλογής με βάση το μέγεθος}
\label{fig:expr_size}
\end{figure}

Τέλος, πρέπει να αναφέρουμε ότι ο πίνακας των ενδιάμεσων αποτελεσμάτων είναι, πλέον, κοινόχρηστος από τα νήματα.
Οπότε, για να αποφευχθούν συνθήκες ανταγωνισμού για τα κελιά του, πρέπει αυτά να προστατεύονται από κλειδώματα.
Ένας απλός και αποτελεσματικός τρόπος είναι κάθε κελί να έχει το κλειδί του, οπότε για να το υπολογίσει κάποιος θα πρέπει να το κλειδώσει (Σχ. \ref{fig:lock})

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
cur_cell->lock();
cur_cell->set_res(Result::pending);
cur_cell->unlock();
\end{minted}
  \caption{Κλείδωμα του κελιού}
\label{fig:lock}
\end{figure}

Συγκεκριμένα το "μαρκάρει" ως pending, οπότε αν κάποιο άλλο νήμα πάει να ζητήσει το αποτέλεσμά του, θα πρέπει να περιμένει μέχρι η κατάσταση pending να αλλάξει (Σχ. \ref{fig:pending}):

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
case Result::pending:
{
    while (cur_cell->res() == Result::pending) 
        std::this_thread::sleep_for(std::chrono::milliseconds(0));
    ...
}
\end{minted}
  \caption{Αναμονή για υπολογισμό του κελιού από άλλο νήμα}
\label{fig:pending}
\end{figure}

\subsection{Αναδρομική δημιουργία νημάτων}

Στην προηγούμενη υποενότητα εξετάσαμε τη σχετικά απλή περίπτωση όπου ένα νήμα (master) καλούσε επιμέρους νήματα (workers), για να επιταχύνει τη συντακτική ανάλυση στην περίπτωση της διατεταγμένης επιλογής.
Ωστόσο, αυτά τα νήματα-εργάτες λειτουργούσαν σειριακά.
Δηλαδή, αν συναντούσαν με τη σειρά τους μία σύνθετη έκφραση διατεταγμένης επιλογής, δεν θα δημιουργούσαν καινούρια νήματα, αλλά θα ανέλυαν με τη σειρά τις υποεκφράσεις.

Τώρα, θα επιχειρήσουμε να επεκτείνουμε τη λογική μας, ώστε κάθε νήμα-εργάτης να μπορεί με τη σειρά του να καλέσει και άλλα νήματα-εργάτες.
Αυτό εισάγει δύο (τουλάχιστον) δυσκολίες:

\begin{itemize}
	\item Μία καθολική μεταβλητή συγχρονισμού δεν αρκεί, αλλά πρέπει να εισαχθεί μία μεταβλητή για κάθε νήμα-εργάτη, ώστε να ελέγχει τα νήματα που δημιουργεί στο επόμενο επίπεδο.
	\item Πλέον, δύναται να δημιουργηθούν πάρα πολλά νήματα, οπότε πρέπει να καθοριστούν αντίστοιχοι περιορισμοί, που θα φράσσουν την ανεξέλεγκτη δημιουργία νημάτων.
\end{itemize}

Όπως και πριν, κάθε γονικό νήμα μόλις καλέσει τα παιδιά-νήματα τα περιμένει ένα ένα να τελειώσουν βάσει ιεραρχίας.
Ωστόσο, τώρα κάθε νήμα-γονέας έχει τη δική του $finished\_rank$ ατομική μεταβλητή, όπως φαίνεται στο Σχήμα \ref{fig:rec_top_down_worker}.
Μέσω αυτής ελέγχει τα νήματα-παιδιά (γρ. 6).
Επιπλέον, για να μπορεί να το ελέγχει και αυτό αντίστοιχα ο δικός του γονέας, διαθέτει και ένα δείκτη προς την ατομική μεταβλητή αυτού (γρ. 7).

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
class SimpleWorker: public SerialPackrat {
    int expr_limit;
    int cur_tree_depth;
    int max_tree_depth;
    int rank;
    std::atomic<int> finished_rank{-1};
    std::atomic<int>* parent_finished_rank;
public:
    ...
};

\end{minted}
\caption{Ορισμός της κλάσης του νήματος-εργάτη}
\label{fig:rec_top_down_worker}
\end{figure}

Στην προηγούμενη υποενότητα εισάγαμε την παράμετρο $expr\_limit$ για να καθορίζουμε μέχρι πόσα παιδιά θα καλεί το αρχικό νήμα.
Αν η σύνθετη έκφραση είχε περισσότερα από $expr\_limit$ παιδιά, τότε το νήμα την ανέλυε σειρακά.
Έτσι και τώρα, κάθε νήμα έχει ένα όριο στο πόσα παιδιά θα μπορεί να καλέσει (Σχ. \ref{fig:rec_top_down_spawn}, γρ. 9).

Επιπλέον, τώρα χρειαζόμαστε και μία παράμετρο που θα φράσσει το βάθος του δέντρου (fork-join tree).
Η μεταβλητή $max\_tree\_depth$, λοιπόν, θα καθορίζεται άπαξ στο αρχικό νήμα, το οποίο θα τη στέλνει στα παιδιά-νήματα.
Κάθε νήμα θα έχει μία μεταβλητή $cur\_tree\_depth$ που θα δείχνει το τρέχον βάθος, όπως φαίνεται στον ορισμό της κλάσης του.
Όταν καλεί ένα νήμα-παιδί, θα του δίνει $cur\_tree\_depth + 1$ ως βάθος (γρ. 10).
To νήμα-γονέας δίνει στα παιδιά και ένα δείκτη προς την ατομική μεταβλητή του, ώστε να μπορεί να τα ειδοποιήσει να τερματίσουν (γρ. 10).
Πάντα το νήμα πρέπει να ξαναθέτει την ατομική μεταβλητή του σε -1, διότι μπορεί να επισκεπτεί πάνω από μία διατεταγμένες επιλογές (γρ. 1).
\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
finished_rank.store(-1);

int results[exprs.size()];
int positions[exprs.size()];
std::vector<std::thread> threads;

auto i = 0;
for (auto& expr : exprs) {
    threads.emplace_back([&, expr, i]()
    {
        SimpleWorker sw{in, peg, cells, pos, expr_limit, 
                        cur_tree_depth + 1, max_tree_depth, i, &finished_rank};
        results[i] = expr->accept(sw);
        positions[i] = sw.cur_pos();
    });
    i++;
}
\end{minted}
  \caption{Tο νήμα-εργάτης δημιουργεί νήματα-εργάτες}
\label{fig:rec_top_down_spawn}
\end{figure}

Το νήμα-γονέας με το πρώτο παιδί που επιστρέφει επιτυχώς βάζει το $rank$ του παιδιού στο $finished\_rank$ του (Σχήμα \ref{fig:rec_top_down_join}, γρ. 4). 

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
for (auto j = 0; j < i; ++j) {
    threads[j].join();
    if (results[j]) {
        finished_rank.store(j);
        pos = positions[j];
        for (auto k = j + 1; k < i; ++k) {
            threads[k].join();
        }
        return true;
    }
}
pos = orig_pos;
return false;
\end{minted}
  \caption{Αναμονή και τερματισμός των νημάτων}
\label{fig:rec_top_down_join}
\end{figure}

Οπότε, τα επόμενα παιδιά μετά θα διαβάσουν κάποια στιγμή ότι το $parent\_finished\_rank$ που αντιστοιχεί σε αυτά έχει τεθεί με νούμερο μεγαλύτερης ιεραρχίας, και θα επιστρέψουν ανεπιτυχώς.
Ο έλεγχος για πρόωρο τερματισμό γίνεται χρησιμοποιώντας το δείκτη προς την ατομική μεταβλητή του γονέα (Σχήμα \ref{fig:rec_top_down_stop}).

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
    auto fr = parent_finished_rank->load();
    if (fr >= 0 && fr < rank) { 
        return false;
    }
\end{minted}
\caption{Έλεγχος της μεταβλητής του γονέα για πρόωρο τερματισμό}
  \label{fig:rec_top_down_stop}
\end{figure}


\section{Παράλληλο Elastic Packrat Parsing}
Οι ιδέες που περιγράψαμε παραπάνω για την παραλληλοποίηση του κλασσικού αλγορίθμου packrat, εφαρμόζονται άμεσα και στο elastic packrat parsing με ελάχιστες τροποποιήσεις.
Όπως περιγράψαμε σε προηγούμενο κεφάλαιο, το elastic packrat parsing διαφέρει με τον κλασσικό αλγόριθμο στον τρόπο με τον οποίο αποθηκεύονται τα δεδομένα.
Συγκεκριμένα, αντί για δισδιάστατο πίνακα, κρατάει έναν μονοδιάστατο μικρότερου μεγέθους στον οποίο αντιστοιχίζονται ζεύγη $(position, non terminal)$, όπου non terminal είναι ένα ενεργοποιμένο μη τερματικό.
Οπότε, και πάλι κάθε στοιχείο του πίνακα έχει ένα κλείδωμα το οποίο αποτρέπει τις συνθήκες ανταγωνισμού για το κελί.

