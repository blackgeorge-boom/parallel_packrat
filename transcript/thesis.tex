\documentclass[diploma]{softlab-thesis}

%%%
%%%  Add and configure the packages that you need for your thesis
%%%

\usepackage{minted}
\usepackage{amsmath}


%%%
%%%  The document
%%%

\begin{document}

%%%  Title page

\frontmatter

\title{Σχεδίαση και Υλοποίηση μιας Καταπληκτικής Γλώσσας Προγραμματισμού}
\author{Νίκος Π. Μαυρογεώργης}
\authoren{Nikos P. Mavrogeorgis}
\date{Αύγουστος 2019}
\datedefense{26}{8}{2019}

\supervisor{Νικόλαος Σ. Παπασπύρου}
\supervisorpos{Καθηγητής Ε.Μ.Π.}

\committeeone{Νικόλαος Σ. Παπασπύρου}
\committeeonepos{Καθηγητής Ε.Μ.Π.}
\committeetwo{Πέτρος Παπαδόπουλος}
\committeetwopos{Επίκ. Καθηγητής Ε.Μ.Π.}
\committeethree{Γεώργιος Νικολάου}
\committeethreepos{Αν. Καθηγητής Ε.Κ.Π.Α.}

\TRnumber{CSD-SW-TR-42-17}  % number-year, ask nickie for the number
\department{Τομέας Τεχνολογίας Πληροφορικής και Υπολογιστών}

\maketitle


%%%  Abstract, in Greek

\begin{abstractgr}%
  Σκοπός της παρούσας εργασίας είναι αφενός η σχεδίαση μίας απλής
  γλώσσας υψηλού επιπέδου με υποστήριξη για προγραμματισμό με
  αποδείξεις, αφετέρου η υλοποίηση ενός μεταγλωττιστή για τη γλώσσα
  αυτή που θα παράγει κώδικα για μία γλώσσα ενδιάμεσου επιπέδου
  κατάλληλη για δημιουργία πιστοποιημένων εκτελέσιμων.

\begin{keywordsgr}
  Γλώσσες προγραμματισμού,
  Προγραμματισμός με αποδείξεις,
  Ασφαλείς γλώσσες προγραμματισμού,
  Πιστοποιημένος κώδικας.
\end{keywordsgr}
\end{abstractgr}


%%%  Abstract, in English

\begin{abstracten}%
  The purpose of this diploma dissertation is on one hand the design
  of a simple high-level language that supports programming with
  proofs, and on the other hand the implementation of a compiler for
  this language. This compiler will produce code for an
  intermediate-level language suitable for creating certified
  binaries.

  \begin{keywordsen}
  Programming languages,
  Programming with proofs,
  Secure programming languages,
  Certified code.
\end{keywordsen}
\end{abstracten}


%%%  Acknowledgements

\begin{acknowledgementsgr}
  Ευχαριστώ θερμά τον επιβλέποντα καθηγητή αυτής της διατριβής,
  κ.~Νίκο Παπασπύρου
\end{acknowledgementsgr}

\begin{acknowledgementsen}
  I would like to thank all the people who supported my work and helped me get
  results of better quality.  
\end{acknowledgementsen}


%%%  Various tables

\tableofcontents
%\listoftables
\listoffigures
%\listofalgorithms


%%%  Main part of the book

\mainmatter

\chapter{ Εισαγωγή }

Κάθε γλώσσα προγραμματισμού από τη φάση σχεδιασμού της έχει ακριβείς κανόνες που καθορίζουν τη συντακτική δομή των σωστά διατυπωμένων προγραμμάτων της. \cite{dragon}
Στη C, για παράδειγμα, ένα πρόγραμμα αποτελείται από συναρτήσεις, μια συνάρτηση από δηλώσεις και εντολές, μια εντολή από εκφράσεις, και ούτω καθ' εξής.
Πρακτικά όλες οι γλώσσες που χρησιμοποιούνται συχνά σήμερα, τόσο φυσικές γλώσσες όσο και γλώσσες μηχανής, βασίζονται στην έκφραση της πληροφορίας με γραμμικό τρόπο, όπως οι ακολουθίες συμβόλων  \cite{ford-thesis}.
Το κείμενο σε μία γραπτή γλώσσα συνήθως αναπαρίσταται ως μία  \textit{ συμβολοσειρά}, δηλαδή μια ακολουθία χαρακτήρων που προέρχονται από ένα τυποποιημένο σύνολο. 
Το πρώτο πράγμα που πρέπει να κάνει οποιαδήποτε εφαρμογή επεξεργασίας γλώσσας, είναι να μετατρέψει αυτές τις συμβολοσειρές σε πιο αφηρημένες δομές όπως λέξεις, φράσεις, προτάσεις, εκφράσεις ή εντολές.
Η διαδικασία που εξάγει τέτοια χρήσιμη δομημένη πληροφορία από γραμμικό κείμενο είναι γνωστή ως συντακτική ανάλυση ή parsing.

\section{ Ορισμός συντακτικού}

Προκειμένου να κατασκευάσουμε έναν συντακτικό αναλυτή (ή  parser) για μία γλώσσα, ή ακόμα και για να ορίσουμε τυπικά ποια είδη συμβολοσειρών έχουν νόημα σε αυτήν, πρέπει να έχουμε έναν τρόπο να για να εκφράσουμε και να κατανοήσουμε τη συντακτική δομή της.
Για το σκοπό αυτό συνήθως χρησιμοποιούμε κάποια  \textit{ γραμματική}, που είναι μία συμπαγής αναπαράστησαση της δομής μίας γλωσσας, εκφρασμένη σε κάποια άλλη (ιδανικά μικρή και απλή) γλώσσα.
Η γλώσσα της οποίας της δομή προσπαθούμε να αναπαραστήσουμε είναι η  \textit{ γλώσσα αντικείμενο}, ενώ η γλώσσα στην οποία \textit{ εκφράζεται} η συντακτική δομή ονομάζεται  \textit{γραμματική ορισμού γλώσσας}. 

Ο πιο συνηθισμένος τύπος γραμματικής σήμερα, είναι οι \textit{γραμμτικές χωρίς συμφραζόμενα ( context-free grammars - CFG)}, εκφρασμένες σε  Backus-Naur Form (BNF). 
Μία γραμματική χωρίς συμφραζόμενα ουσιαστικά εκφράζει ένα σύνολο αμοιβαίως αναδρομικών κανόνων, οι οποίες περιγράφουν πώς μπορουυν να γραφτούν οι συμβολοσειρές που περιγράφονται στη γλώσσα.
Κάθε κανόνας ή \textit{ παραγωγή}  σε μία  CFG καθορίζει έναν τρόπο με τον οποίο μία συντακτική μεταβλητή ή  \textit{ μη τερματικό} μπορεί να αντικατασταθεί σε μία συμβολοσειρά. 
Ένα μη τερματικό μπορεί να αντικατασταθείξλ σε μία συμβολοσειρά που μπορεί να περιέχει άλλα μη τερματικά, τα οποία θα αντικατασταθούν με τη σειρά τους, ώσπου να μην υπάρχουν άλλα.
Επειδή υπάρχουν πολλοί τρόποι για να αντικατασταθεί ένα μη τερματικό, η γραμματική μπορεί να εκφράσει ένα άπειρο σύνολο καλώς ορισμένων συμβολοσειρών.
Η συντακτική ανάλυση μιας συμβολοσειράς, της οποίας η σύνταξη περιγράφεται από μία  CFG, περιλαμβάνει την ανάποδη διαδικασία: 
να καθοριστεί από μία πλήρως ανεπτυγμένη συμβολοσειρά, η οποία περιέχει μόνο ατομικούς χαρακτήρες ή  \textit{ τερματικά}, ποια ακολουθία (ή ακολουθίες βημάτων) αντικατάστασης, αν υπάρχουν, οδηγούν στην παραγωγή της συμβολοσειράς.
Αυτή η εργασία περιπλέκεται καθώς οι  CFGs  συνήθως περιέχουν αμφισημίες:
σε  \textit{τοπικό επίπεδο}, όπου η σωστή ερμηνεία ενός τμήματος της συμβολοσειράς μπορεί να καθοριστεί μόνο από τα συμφραζόμενα; 
σε \textit{καθολικό επίπεδο}, όπου ολόκληρη η συμβολοσειρά μπορεί να έχει πολλαπλές έγκυρες συντακτικές ερμηνείες.

\section{ Parsing Expression Grammars}
 Η θεωρία και η πράξη της συντακτικής ανάλυσης βασίζεται σε \textit{ παραγωγικά ( generative)} συστήματα, όπως οι κανονικές εκφράσεις και οι γραμματικές χωρίς συμφραζόμενα, στα οποία η γλώσσα ορίζεται τυπικά μέσα από κανόνες οι οποίοι όταν εφαρμοστούν αναδρομικά παράγουν συμβολοσειρές της γλώσσας.
Αντίθετα, σε ένα \textit{ αναγνωριστικό σύστημα ( recognition-based system)} η γλώσσα ορίζεται μέσα από κανόνες ή κατηγορήματα που αποφασίζουν εάν η δοθείσα συμβολοσειρά ανήκει στη γλώσσα \cite{ford-peg}.
Οι απλές γλώσσες μπορούν να εκφραστούν εξίσου εύκολα και στα δύο συστήματα.
 Για παράδειγμα, το $\{ s \in \mathbf{a}^* | s = {(\mathbf{a}\mathbf{a})}^n\}$ είναι ένας παραγωγικός ορισμός μιας γλώσσας με ένα μόνο γράμμα στο λεξιλόγιό της, της οποίας οι συμβολοσειρές 
 κατασκευάζονται συνενώνοντας ζεύγη από $ \mathbf{a}$.
 Από την άλλη, το $\{ s \in \mathbf{a}^* | (\lvert s \rvert mod2=0)\}$, είναι ένας αναγνωριστικός ορισμός, όπου μία συμβολοσειρά από  $\mathbf{a}$'s γίνεται αποδεκτή μόνο αν το μήκος της είναι άρτιο.
 
  Αν και το παραγωγικό μοντέλο χρησιμοποιείται ευρύτατα στη θεωρία γλωσσών, οι πιο πολλές πρακτικές γλωσσικές εφαρμογές περιλαμβάνουν την αναγνώριση και τη δομική ανάλυση συμβολοσειρών. 
Εμείς θα χρησιμοποιήσουμε το αναγνωριστικό μοντέλο για τη σύνταξη της γλώσσας, η οποία θα περιγράφεται από τις  \textit{Parsing Expression Grammars (PEGs)}. Αυτές μοιάζουν με τις γραμματικές χωρίς συμφραζόμενα με την προσθήκη χαρακτηριστικών από τις κανονικές εκφράσεις, όμοια με την  Extended BNF σημειογραφία.

\section{ Packrat Parsing}
Με βάση τις Parsing Expression Grammars και το αναγνωριστικό σχήμα, ο απλούστερος τρόπος να αναλυθεί (συντακτικά) μία συμβολοσειρά έιναι μέσω ενός αναδρομικού καθοδικού συντακτικού αναλυτή, με δυνατόττηα για οπισθαναχώρηση ( backtracking). 
Ωστόσο, σε πολλές  PEGs  ένας συνήθης καθοδικός αναλυτής μπορεί να κάνει εκθετικό χρόνο για να αναγνωρίσει μία συμβολοσειρά στην είσοδο. 
Και αυτό διότι η οπισθαναώρηση μπορεί να οδηγήσει σε πλεονάζοντες υπολογισμούς ενδιάμεσων αποτελεσμάτων.
Αν, όμως, χρησιμοποιηθεί \textit{ υπομνηματισμός ( memoisation)} για να αποφευχθούν τέτοιοι πλεονασμοί, μία  PEG  μπορεί να αναλυθεί σε γραμμικό χρόνο με το μήκος της εισόδου.
Ένας τέτοιος συντακτικός αναλυτής ονομάζεται \textit{Packrat Parser}.

\section{ Αυτόματη παραγωγή των  Packrat Parsers}
Αν και το  packrat parsing είναι εύκολο να υλοποιηθεί με το χέρι, θα ήταν ακόμη καλύτερο να μπορούσαμε να κατασκευάσουμε τέτοιους συντακτικούς αναλυτές με αυτόματο τρόπο, όμοια με το  YACC  στον κόσμο της C. 
Ένας \textit{γεννήτορας συντακτιών αναλυτών (parser generator)} παίρνει ως είσοδο μία τυπική περιγραφή της γραμματικής και "γεννάει" τον αντίστοιχο συντακτικό αναλυτή  σε  C++.
Η περιγραφή που δέχεται ο δικός μας γεννήτορας βασίζεται στη σημειογραφία των  PEGs. 
Τέλος, παρέχει και τη δυνατότητα να επιστραφεί το συντακτικό δέντρο μετά την ανάλυση, ενώ επεκτείνεται εύκολα ώστε να κρατήσει και άλλες σημασιολογικές τιμές.
Οι βασικές ιδέες για την υλοποίησή του πηγάζουν από πρότερη δουλειά που έχει γίνει σε  Java \cite{fowler} \cite{lgi}.

\section{  Παράλληλο Packrat Parsing}
Αφού  υλοποιήσουμε έναν  packrat parser generator σε C++, η βασική συνεισφορά που θέλουμε να κάνουμε στα πλαίσια της διπλωματικής, είναι να εξετάσουμε κατά πόσο και πώς ένας σειριακός packrat parser μπορεί να παραλληλοποιθεί ώστε να τρέχει αποδοτικότερα σε ένα πολυπύρηνο σύστημα με αρχιτεκτονική κοινής μνήμης.
Η πρώτη προσέγγιση που έχει δοκιμαστεί \cite{fowler} είναι να χωρίζεται η είσοδος σε κομμάτια και να αναλαμβάνει ένα νήμα να υπολογίσει τα κελιά του συντακτικού αναλυτή που αφορούν το συγκεκριμένο κομμάτι. (% TODO: add more about seith fowler)
H  πρώτη δική μας προσέγγιση ήταν να αντί για υπομνηματισμό, να χρησιμοποιήσουμε δυναμικό προγραμματισμό, τον οποίο επειτα δοκιμάσαμε να παραλληλοποιήσουμε.
Ακολούθως, εφαρμόσαμε παραλληλοποίηση στην πράξη της \textit{ επιλογής ( choice)} των  PEGs % TODO: add more about pht
Τέλος, αφού υλοποιήσαμε το  Elastic % TODO: 

\section{  Η δομή της εργασίας}

\chapter{ Parsing Expression Grammars }

\section{Σημασιολογία γλωσσών προγραμματισμού}

\section{Θεωρία πεδίων}

\chapter{ Packrat Parsing }

\chapter{ Παράλληλο Packrat Parsing με Υπομνηματισμό }

\chapter{ Seith Fowler}

\chapter{ Παράλληλο Ordered Choice }

\chapter{ Παράλληλo Elastic Packrat Parsing }

\chapter{  Πειραματικά Αποτελέσματα }

\chapter{ Συμπεράσματα - Μελλοντική Δουλειά }

\englishtext

\chapter{Introduction}

\section{The Goal of this Project}

\section{The C++ Programming Language}


\begin{figure}[t]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
#include <iostream>
int main() {
  std::cout << "Hello world!" << std::endl;
}
\end{minted}
\caption{Filled with joy, the Agha decides to write some code.%
  \label{fig:hello-english}}
\end{figure}


\section{The Structure of this Thesis}

\chapter{Theoretical Background}

\section{Programming Language Semantics}

\section{Domain Theory}

\selectlanguage{greek}


%%%  Bibliography

% You shouldn't want to include all the contents of thesis.bib
% in your bibliography (do you?)
\nocite{*}

\bibliographystyle{softlab-thesis}
\bibliography{thesis}


%%%  Appendices

\backmatter

\appendix

\chapter{Ευρετήριο συμβολισμών}

$A \rightarrow B$ : συνάρτηση από το πεδίο $A$ στο πεδίο $B$.

\chapter{Ευρετήριο γλωσσών}

\begin{description}
\item[C++:] πώς θα βγάλω λεφτά...
\item[Haskell:] η γλώσσα της ζωής μου αλλά πάνε οι μπύρες...
\item[Javascript:] χα, χα, χα...
\item[Python:] πώς θα τελειώνω για να πάω για μπύρες...
\end{description}


\chapter{Ευρετήριο αριθμών}

\begin{description}
\item[17:] ask Zachos.
\item[42:] life, the universe and everything --- ask Douglas.
\end{description}


%%%  End of document

\end{document}
