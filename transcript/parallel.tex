\chapter{ Parallel Packrat Parsing }
\label{ch:parallel}

Η βασική συνεισφορά που θέλουμε να κάνουμε στα πλαίσια της διπλωματικής, είναι να τροποποιήσουμε τη σειριακή έκδοση του packrat parser, ώστε να μπορεί να τρέξει αποδοτικότερα σε ένα πολυπύρηνο σύστημα.
Επιπλέον, θα δοκιμάσουμε τα παραλληλοποιήσουμε όχι μόνο την κλασική έκδοση του packrat, αλλά και παραλλαγών της.

To πρόβλημα εύρεσης παραλληλισμού δεν είναι καθόλου τετριμμένο εν γένει. 
Ειδικά στην περίπτωση μας, θα πρέπει να εξετάσουμε διάφορα κομμάτια του αλγορίθμου που μπορούν να μοιραστούν μεταξύ των νημάτων, καθώς και πώς τα νήματα αυτά θα προσπελάσουν τη δομή δεδομένων με τα ενδιάμεσα αποτελέσματα.
Εδώ, πρέπει να προσέξουμε ιδιαιτέρως δύο σημεία:

\begin{itemize}
	\item Η πρόσβαση σε κάθε κελί της δομής δεδομένων πρέπει να γίνεται με \textit{αμοιβαίο αποκλεισμό (mutual exlusion)} μεταξύ των νημάτων.
	\item Θέλουμε η \textit{αναμονή (waiting)} των νημάτων να είναι όσο το δυνατόν μικρότερη.
\end{itemize}

Θα ξεκινήσουμε πρώτα με τον αλγόριθμο δυναμικού προγραμματισμού για το packrat parsing (DP packrat).
Ακολούθως, θα επικεντρωθούμε στον αλγόριθμο με υπομνηματισμό.
Θα δούμε τί έχει δοκιμαστεί ως τώρα από την επιστημονική κοινότητα, ενώ θα επιχειρήσουμε και δικές μας προσεγγίσεις.

\section{Παράλληλος DP packrat}

Η εκδοχή με τον από κάτω προς τα κάτω αναλυτή, μπορεί να παραλληλοποιηθεί εύκολα (embarassingly parallel). 
Αναθέτοντας σε κάθε νήμα από μία στήλη του πίνακα για υπολογίσει, μπορούμε να σπάσουμε εύκολα το αρχικό πρόβλημα σε επιμέρους υποπροβλήματα.


\begin{table}
\begin{tabular}{l | a | b | a | a | a | b | b | b}
\hline
1 & a & b & a & b & c & d & c & d\\
2 & a & b & a & b & c & d & c & d\\ \hline
2 & a & b & a & b & c & d & c & d\\ \hline
2 & a & b & a & b & c & d & c & d\\ \hline
2 & a & b & a & b & c & d & c & d\\ \hline
\end{tabular}
\end{table}

Βέβαια, δεν αναμένουμε να είναι γραμμική η επιτάχυνση του αλγορίθμου καθώς τα αποτελέσματα της στήλης ενός νήματος μπορεί να εξαρτώνται από τις τιμές των κελιών που βρίσκονται στις στήλες άλλων νημάτων.
Έτσι, ένα νήμα θα πρέπει να κάνει τη "δουλειά" κάποιου άλλου νήματος, οπότε ο φόρτος δεν μοιράζεται εξίσου.

Όπως και να 'χει, με δεδομένο ότι ο παράλληλος DP Packrat είναι πολύ αργός στη σειριακή περίπτωση, καθώς υπολογίζονται πολλά κελιά του πίνακα που δεν χρειάζονται, επικεντρωνόμαστε εφεξής στον καθοδικό packrat parser και τις παραλλαγές του.

\section{Παράλληλο Καθοδικό Packrat Parsing}

\subsection{Παραλληλοποίηση της Διατεταγμένης Επιλογής}

Η πρώτη ιδέα στη βελτίωση της απόδοσης του καθοδικού Packrat Parser είναι να προσπαθήσουμε να βρούμε κάποιο κομμάτι του αλγορίθμου το οποίο μπορεί να εκτελεστεί από πολλά νήματα ταυτόχρονα, ώστε να μοιραστεί ο φόρτος εργασίας.
Έτσι, το κομμάτι αυτό του αλγορίθμου θα μπορεί να εκτελεστεί ταχύτερα, οδηγώντας και σε ταχύτερη εκτέλεση συνολικά.

Επαναλαμβάνουμε ότι ο αναλυτής μας "επισκέπτεται" κάθε στοιχείο της γραμματικής για να την αναλύσει.
Αρχικά, θα πάει στο αρχικό μη τερματικό της γραμματικής. 
Ακολούθως, θα πάει στη σύνθετη έκφραση που αντιστοιχεί σε αυτό το μη τερματικό.
Μία ιδέα θα ήταν να προσπαθήσουμε να παραλληλοποιήσουμε τη συντακτική ανάλυση των σύνθετων εκφράσεων.

Προφανώς, για μία ακολουθία από εκφράσεις:

\begin{equation}
	E \leftarrow E_1 E_2 E_3
\end{equation}

θα ήταν δύσκολο να αναθέσουμε μία υποέκφραση $E_i$ σε κάθε νήμα, καθώς πρέπει πρώτα να προσπαθήσουμε να αναλύσουμε την $E_1$ και, αν πετύχει, να αναλύσουμε την $E_2$ συνεχίζοντας από το σημείο της εισόδου που μας άφησε η $E_1$. 
Επειδή, δεν ξέρουμε εκ των προτέρων ποιο θα είναι αυτό, δεν μπορούμε έτσι απλά να δώσουμε την $E_2$ να την υπολογίσει άλλο νήμα.

Ωστόσο, στη διατεταγμένη ακολουθία:

\begin{equation}
	E \leftarrow E_1 / E_2 /  E_3
\end{equation}

οι υποεκφράσεις αναλύονται ξεκινώντας από το ίδιο σημείο της εισόδου (αν αποτύχει η $E_1$, τότε ξαναπροσπαθεί από το ίδιο σημείο η $E_2$ κλπ).
Θεωρητικά, λοιπόν, θα μπορούσαμε να τις αναθέσουμε σε ξεχωριστά νήματα.
Εδώ, όμως, χρειάζεται προσοχή.
Αν το νήμα που αναλύσει την $E_2$, επιστρέψει επιτυχώς, πρέπει πάλι να περιμένουμε το νήμα που αναλύει την $E_1$, καθώς η υποέκφραση αυτή έχει προτεραιότητα.

Συνεπώς, η κύρια διεργασία που έχει αναλάβει την ανάλυση της έκφρασης $E$ θα πρέπει να καλέσει ξεχωριστά νήματα-εργάτες για κάθε υποέκφραση, αλλά να τηρήσει την ιεραρχία:

\begin{itemize}
	\item Πρώτα περιμένει να ολοκληρώσει το νήμα της $E_1$.
	\item Αν επιτύχει, τότε στέλνει σήμα στα υπόλοιπα νήματα να επιστρέψουν.
	\item Αλλιώς, περιμένει να τελειώσει το δεύτερο νήμα.
	\item Η διαδικασία συνεχίζεται μέχρις ότου κάποιο νήμα επιστρέψει επιτυχώς (οπότε τερματίζονται τα 
	  επόμενα στην ιεραρχία), είτε αν επιστρέψουν όλα τα νήματα ανεπιτυχώς. % TODO: fix indent
\end{itemize}

Αν όλα επιστρέψουν ανεπιτυχώς, τότε και το κύριο νήμα που τα κάλεσε επιστρέφει ανεπιτυχώς και θέτει τη θέση στην είσοδο, όπως ήταν στην αρχή (reset).
Αλλιώς, το πρώτο νήμα στην ιεραρχία που πέτυχε καθορίζει και από ποιο σημείο της εισόδου θα συνεχίσει η ανάλυση.

Ενδεικτικά, ο κώδικας που θα υλοποιούσε κάτι τέτοιο φαίνεται στην Σχήμα \ref{fig:top_down_1}.

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
finished_rank.store(-1);

int results[exprs.size()];
int positions[exprs.size()];
std::vector<std::thread> threads;

auto i = 0;
for (auto& expr : exprs) { 
    threads.emplace_back([&, expr, i, this]()
    {
        SimpleWorker sw{in, peg, cells, pos, i};
        results[i] = expr->accept(sw);
        positions[i] = sw.cur_pos();
    });
    i++;
}

auto j = 0;
for (auto w : workers) {
    threads[j].join(); 
    if (results[j]) { 
        finished_rank.store(j);
        pos = positions[j];
        for (auto k = j + 1; k < workers.size(); ++k) {
            threads[k].join();
        }
        return true;
    }
    j++;
}
pos = orig_pos;
return false;
\end{minted}
\caption{Δημιουργία και τερματισμός νημάτων με βάση την ιεραρχία για κάθε υποέκφραση}
\label{fig:top_down_1}
\end{figure}

Για να έχει νόημα η παραπάνω παραλληλοποίηση πρέπει να διασφαλίζουμε ότι όταν ένα νήμα επιστρέφει επιτυχώς, τα επόμενα στην ιεραρχία θα τερματίζονται όσο το δυνατόν γρηγορότερα.
Για το σκοπό αυτό, υπάρχει μία καθολική μεταβλητή $finished\_rank$, η οποία κρατάει το νούμερο του νήματος που ολοκλήρωσε επιτυχώς, αρκεί να μην υπάρχουν νήματα πιο πάνω στην ιεραρχία που επίσης έχουν επιστρέψει επιτυχώς.
Για λόγους συγχρονισμού, η μεταβλητή αυτή είναι ατομική.
Στην αρχή τίθεται ως $-1$ από το κύριο νήμα.

Θεωρούμε ότι σε κάθε νήμα-εργάτη έχει δοθεί ένα μοναδικό νούμερο $rank$, όπου ψηλότερα στην ιεραρχία είναι το νούμερο $0$.
Το κύριο νήμα δίνει το $rank$ στα παιδιά του και τα περιμένει μετά ένα ένα να επιστρέψουν βάσει ιεραρχίας.
Αν κάποιο επιστρέψει επιτυχώς, το κύριο νήμα θέτει τη μεταβλητή $finished\_rank$ με το rank του νήματος.

Άρα, σε κάθε αναδρομική κλήση που κάνει το νήμα-εργάτης προτού επισκεφθεί κάθε έκφραση, κάνει τον έλεγχο του Σχήματος \ref{fig:top_down_2} για πρόωρο τερματισμό.
Εάν το $finished_rank$ έχει τεθεί από νήμα μεγαλύτερης ιεραρχίας (μικρότερο $rank$), τότε το τρέχον νήμα πρέπει να επιστρέψει αμέσως.

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
    auto fr = finished_rank.load();
    if (fr >= 0 && fr < rank) { 
        return false;
    }
\end{minted}
\caption{Έλεγχος της καθολικής μεταβλητής για πρόωρο τερματισμό}
\label{fig:top_down_2}
\end{figure}

%\begin{minipage}{\textwidth} TODO

Βέβαια, θα υπάρχουν και περιπτώσεις όπου η διατεταγμένη επιλογή θα περιλαμβάνει πολλές εναλλακτικές, ιδιαίτερα στα μη τερματικά που αφορούν τη λεκτική ανάλυση του προγράμματος, όπως φαίνεται στην Σχήμα \ref{fig:top_down_4}

\begin{figure}[h]
\begin{Verbatim}


	HexDigit <- 'a' / 'b' / 'c' / 'd' / 'e' / 'f' / 
   		 'A' / 'B' / 'C' / 'D' / 'E' / 'F' / Digit
\end{Verbatim}
\caption{Κανόνας με πολλές εναλλακτικές στη διατεταγμένη επιλογή}
\label{fig:top_down_4}
\end{figure}

%\end{minipage}

Συνήθως, όταν υπάρχουν πολλές εναλλακτικές στη διατεταγμένη επιλογή, αυτές αποτελούν τερματικά (κυρίως για τους κανόνες που αφορούν λεκτική ανάλυση), τα οποία μπορούν να αναλυθούν άμεσα. 
Στην περίπτωση αυτή, μάλλον δεν είναι συμφέρον για το κύριο νήμα να καλέσει ένα νήμα για την ανάλυση της κάθε υποέκφρασης, καθώς το κόστος τόσο της κλήσης πολλών νημάτων, όσο και της αναμονής να τελειώσουν (join) θα είναι μεγάλο.
Τότε, συμφέρει καλύτερα το κύριο νήμα να αναλύσει τη διατεταγμένη επιλογή μόνο του, παρά να καλέσει άλλα νήματα-εργάτες. 
Ο κώδικας φαίνεται στο Σχήμα \ref{fig:expr_size}.

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
if (exprs.size() > size_limit) {    // Parse without spawning threads
    for (auto expr : exprs) {
        pos = orig_pos;
        if (expr->accept(*this))
            return true;
    }
    pos = orig_pos;
    return false;
}
\end{minted}
\caption{Έλεγχος για την εκτέλεση ή μη της διατεταγμένης επιλογής με βάση το μέγεθος}
\label{fig:expr_size}
\end{figure}

\subsection{Αναδρομική δημιουργία νημάτων}

Στην προηγούμενη υποενότητα εξετάσαμε τη σχετικά απλή περίπτωση όπου ένα νήμα (master) καλούσε επιμέρους νήματα (workers), για να επιταχύνη τη συντακτικη΄ ανάλυση στην περίπτωση της διατεταγμένης επιλογής.
Ωστόσο, αυτά τα νήματα-εργάτες λειτουργούσαν σειριακά.
Δηλαδή, αν συναντούσαν με τη σειρά τους μία σύνθετη έκφραση διατεταγμένης επιλογής, δεν θα δημιουργούσαν καινούρια νήματα, αλλά θα ανέλυαν με τη σειρά τις υποεκφράσεις.

Τώρα, θα επιχειρήσουμε να επεκτείνουμε τη λογική μας, ώστε κάθε νήμα-εργάτης να μπορεί με τη σειρά του να καλέσει και άλλα νήματα-εργάτες.
Αυτό εισάγει δύο (τουλάχιστον) δυσκολίες:

\begin{itemize}
	\item Μία καθολική μεταβλητή συγχρονισμού δεν αρκεί, αλλά πρέπει να εισαχθεί μία μεταβλητή για κάθε νήμα-εργάτη, ώστε να ελέγχει τα νήματα που δημιουργεί στο επόμενο επίπεδο.
	\item Πλέον, δύναται να δημιουργηθούν πάρα πολλά νήματα, οπότε πρέπει να καθοριστούν αντίστοιχοι περιορισμοί, που θα φράσσουν την ανεξέλεγκτη δημιουργία νημάτων.
\end{itemize}

Όπως και πριν, κάθε πατρικό νήμα μόλις καλέσει τα παιδιά-νήματα τα περιμένει ένα ένα να τελειώσουν βάσει ιεραρχίας.
Ωστόσο, τώρα κάθε νήμα-πατέρας έχει τη δική του $finished\_rank$ ατομική μεταβλητή, όπως φαίνεται στο Σχήμα \ref{fig:rec_top_down_worker}.
Μέσω αυτής ελέγχει τα νήματα-παιδιά.
Επιπλέον, για να μπορεί να το ελέγχει και αυτό αντίστοιχα ο πατέρας του, διαθέτει ένα δείκτη προς την ατομική μεταβλητή του.

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
class SimpleWorker: public SerialPackrat {
    int expr_limit;
    int cur_tree_depth;
    int max_tree_depth;
    int rank;
    std::atomic<int> finished_rank{-1};
    std::atomic<int>* parent_finished_rank;
public:
    ...
};

\end{minted}
\caption{Ορισμός της κλάσης του νήματος-εργάτη}
\label{fig:rec_top_down_worker}
\end{figure}

Στην προηγούμενη υποενότητα εισάγαμε την παράμετρο $expr\_limit$ για να καθορίζουμε μέχρι πόσα παιδιά θα καλεί το αρχικό νήμα.
Αν η σύνθετη έκφραση είχε περισσότερα από $expr\_limit$ παιδιά, τότε το νήμα την ανέλυε σειρακά.
Έτσι και τώρα, κάθε νήμα έχει ένα όριο στο πόσα παιδιά θα μπορεί να καλέσει.

Επιπλέον, τώρα χρειαζόμαστε και μία παράμετρο που θα φράσσει το βάθος του δέντρου (fork-join tree).
Η μεταβλητή $max\_tree\_depth$, λοιπόν, θα καθορίζεται άπαξ στο αρχικό νήμα, το οποίο θα τη στέλνει στα παιδιά-νήματα.
Κάθε νήμα θα έχει μία μεταβλητή $cur\_tree\_depth$ που θα δείχνει το τρέχον βάθος, όπως φαίνεται στον ορισμό της κλάσης τους.
Όταν καλεί ένα νήμα-παιδί, θα του δίνει $cur\_tree\_depth + 1$ ως βάθος.

Τα παραπάνω φαίνονται πιο καθαρά στο Σχήμα \ref{fig:rec_top_down_spawn}.
\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
int results[exprs.size()];
int positions[exprs.size()];
std::vector<std::thread> threads;

auto i = 0;
for (auto& expr : exprs) {
    threads.emplace_back([&, expr, i]()
    {
        SimpleWorker sw{in, peg, cells, pos, expr_limit, 
                        cur_tree_depth + 1, max_tree_depth, i, flag_index};
        results[i] = expr->accept(sw);
        positions[i] = sw.cur_pos();
    });
    i++;
}
\end{minted}
  \caption{Tο νήμα-εργάτης δημιουργεί νήματα-εργάτες}
\label{fig:rec_top_down_spawn}
\end{figure}

Το νήμα-πατέρας με το πρώτο παιδί που επιστρέφει επιτυχώς βάζει το $rank$ του παιδιού στο $finished\_rank$ του, οπότε τα επόμενα παιδιά μετά θα διαβάσουν κάποια στιγμή ότι το $parent\_finished\_rank$ που αντιστοιχεί σε αυτά  έχει τεθεί με νούμερο μεγαλύτερης ιεραρχίας, και θα επιστρέψουν ανεπιτυχώς (Σχήμα \ref{fig:rec_top_down_join}).

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
for (auto j = 0; j < i; ++j) {
    threads[j].join();
    if (results[j]) {
        finished_rank.store(j);
        pos = positions[j];
        for (auto k = j + 1; k < i; ++k) {
            threads[k].join();
        }
        return true;
    }
}
pos = orig_pos;
return false;
\end{minted}
  \caption{Αναμονή και τερματισμός των νημάτων}
\label{fig:rec_top_down_join}
\end{figure}

Ο έλεγχος για πρόωρο τερματισμό γίνεται χρησιμοποιώντας το δείκτη προς την ατομική μεταβλητή του γονέα (Σχήμα \ref{fig:rec_top_down_stop}).

\begin{figure}[h]
\setlength\partopsep{-\topsep}% adjusts vertical space after the listing
\begin{minted}[frame=lines,linenos,numbersep=5pt]{c++}
    auto fr = parent_finished_rank->load();
    if (fr >= 0 && fr < rank) { 
        return false;
    }
\end{minted}
\caption{Έλεγχος της μεταβλητής του γονέα για πρόωρο τερματισμό}
  \label{fig:rec_top_down_stop}
\end{figure}


\section{Παράλληλο Elastic Packrat Parsing}
Οι ιδέες που περιγράψαμε παραπάνω για την παραλληλοποίηση του κλασσικού αλγορίθμου packrat, εφαρμόζονται άμεσα και στο elastic packrat parsing με ελάχιστες τροποποιήσεις.
Όπως περιγράψαμε σε προηγούμενο κεφάλαιο, το elastic packrat parsing διαφέρει με τον κλασσικό αλγόριθμο στον τρόπο με τον οποίο αποθηκεύονται τα δεδομένα.
Συγκεκριμένα, αντί για δισδιάστατο πίνακα, κρατάει έναν μονοδιάστατο μικρότερου μεγέθους στον οποίο αντιστοιχίζονται ζεύγη $(position, non terminal)$, όπου non terminal είναι ένα ενεργοποιμένο μη τερματικό.
Οπότε, και πάλι κάθε στοιχείο του πίνακα έχει ένα κλείδωμα το οποίο αποτρέπει τις συνθήκες ανταγωνισμού για το κελί.

