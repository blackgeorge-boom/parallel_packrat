\chapter{ Parallel Packrat Parsing }
\label{ch:parallel}

Η βασική συνεισφορά που θέλουμε να κάνουμε στα πλαίσια της διπλωματικής, είναι να τροποποιήσουμε τη σειριακή έκδοση του packrat parser, ώστε να μπορεί να τρέξει αποδοτικότερα σε ένα πολυπύρηνο σύστημα.
Επιπλέον, θα δοκιμάσουμε τα παραλληλοποιήσουμε όχι μόνο την κλασική έκδοση του packrat, αλλά και παραλλαγών της.

To πρόβλημα εύρεσης παραλληλισμού δεν είναι καθόλου τετριμμένο εν γένει. 
Ειδικά στην περίπτωση μας, θα πρέπει να εξετάσουμε διάφορα κομμάτια του αλγορίθμου που μπορούν να μοιραστούν μεταξύ των νημάτων, καθώς και πώς τα νήματα αυτά θα προσπελάσουν τη δομή δεδομένων με τα ενδιάμεσα αποτελέσματα.
Εδώ, πρέπει να προσέξουμε ιδιαιτέρως δύο σημεία:

\begin{description}[font=$\bullet$\scshape\bfseries]
	\item Η πρόσβαση σε κάθε κελί της δομής δεδομένων πρέπει να γίνεται με \textit{αμοιβαίο αποκλεισμό (mutual exlusion)} μεταξύ των νημάτων.
	\item Θέλουμε η \textit{αναμονή (waiting)} των νημάτων να είναι όσο το δυνατόν μικρότερη.
\end{description}

Θα ξεκινήσουμε πρώτα με τον αλγόριθμο δυναμικού προγραμματισμού για το packrat parsing (DP packrat).
Ακολούθως, θα επικεντρωθούμε στον αλγόριθμο με υπομνηματισμό.
Θα δούμε τί έχει δοκιμαστεί ως τώρα από την επιστημονική κοινότητα, ενώ θα επιχειρήσουμε και δικές μας προσεγγίσεις.

\section{Παράλληλος DP packrat}

Η εκδοχή με τον από κάτω προς τα κάτω αναλυτή, μπορεί να παραλληλοποιηθεί εύκολα (embarassingly parallel). 
Αναθέτοντας σε κάθε νήμα από μία στήλη του πίνακα για υπολογίσει, μπορούμε να σπάσουμε εύκολα το αρχικό πρόβλημα σε επιμέρους υποπροβλήματα.

\definecolor{Gray}{gray}{0.8}
\newcolumntype{g}{>{\columncolor{Gray}}c}
\begin{table}[ht]
\begin{center}
  \begin{tabular}{|c|c|c|g|g|g|g|c|c|}
    \hline
     & & & & & & & &  \\ \hline \hline
     & & & & & & & &  \\ \hline \hline
     & & & & & & & &  \\ \hline \hline
     & & & & & & & &  \\ \hline
  \end{tabular}
\end{center}
\caption{Παραλληλοποίηση ανοδικού Packrat Parser}
    \label{tab:bottom_up}
\end{table}

\newcolumntype{g}{>{\columncolor{Gray}}c}
\begin{table}[ht]
\centering
\begin{tabular}{|c|c|c|g|g|g|g|c|c|c|c|}
\hline
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\ \hline
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\ \hline
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\ \hline
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\ \hline
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\ \hline
1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1\\ 
\hline
	& 	& 	&thr4 &thr3 & thr2 &thr1 & & & & \\ \hline
\end{tabular}
\end{table}

Βέβαια, δεν αναμένουμε να είναι γραμμική η επιτάχυνση του αλγορίθμου καθώς τα αποτελέσματα της στήλης ενός νήματος μπορεί να εξαρτώνται από τις τιμές των κελιών που βρίσκονται στις στήλες άλλων νημάτων.
Έτσι, ένα νήμα θα πρέπει να κάνει τη "δουλειά" κάποιου άλλου νήματος, οπότε ο φόρτος δεν μοιράζεται εξίσου.

Όπως και να 'χει, με δεδομένο ότι το παράλληλος DP Packrat είναι πολύ αργός στη σειριακή περίπτωση, καθώς υπολογίζονται πολλά κελιά του πίνακα που δεν χρειάζονται, επικεντρωνόμαστε εφεξής στον καθοδικό packrat parser και τις παραλλαγές του.

\section{Παράλληλο Καθοδικό Packrat Parsing}

Η πρώτη ιδέα στη βελτίωση της απόδοσης του καθοδικού Packrat Parser είναι να προσπαθήσουμε να βρούμε κάποιο κομμάτι του αλγορίθμου το οποίο μπορεί να εκτελεστεί από πολλά νήματα ταυτόχρονα, ώστε να μοιραστεί ο φόρτος εργασίας.
Έτσι, το κομμάτι αυτό του αλγορίθμου θα μπορεί να εκτελεστεί ταχύτερα, οδηγώντας και σε ταχύτερη εκτέλεση συνολικά.

Επαναλαμβάνουμε ότι ο αναλυτής μας "επισκέπτεται" κάθε στοιχείο της γραμματικής για να την αναλύσει.
Αρχικά, θα πάει στο αρχικό μη τερματικό της γραμματικής. 
Ακολούθως, θα πάει στη σύνθετη έκφραση που αντιστοιχεί σε αυτό το μη τερματικό.
Μία ιδέα θα ήταν να προσπαθήσουμε να παραλληλοποιήσουμε τη συντακτική ανάλυση των σύνθετων εκφράσεων.

Προφανώς, για μία ακολουθία από εκφράσεις:

\begin{equation}
	E \leftarrow E_1 E_2 E_3
\end{equation}

θα ήταν δύσκολο να αναθέσουμε μία υποέκφραση $E_i$ σε κάθε νήμα, καθώς πρέπει πρώτα να προσπαθήσουμε να αναλύσουμε την $E_1$ και, αν πετύχει, να αναλύσουμε την $E_2$ συνεχίζοντας από το σημείο της εισόδου που μας άφησε η $E_1$. 
Επειδή, δεν ξέρουμε εκ των προτέρων ποιο θα είναι αυτό, δεν μπορούμε έτσι απλά να δώσουμε την $E_2$ να την υπολογίσει άλλο νήμα.

Ωστόσο, στη διατεταγμένη ακολουθία:

\begin{equation}
	E \leftarrow E_1 / E_2 /  E_3
\end{equation}

οι υποεκφράσεις αναλύονται ξεκινώντας από το ίδιο σημείο της εισόδου (αν αποτύχει η $E_1$, τότε ξαναπροσπαθεί από το ίδιο σημείο η $E_2$ κλπ).
Θεωρητικά, λοιπόν, θα μπορούσαμε να τις αναθέσουμε σε ξεχωριστά νήματα.
Εδώ, όμως, χρειάζεται προσοχή.
Αν το νήμα που αναλύσει την $E_2$, επιστρέψει επιτυχώς, πρέπει πάλι να περιμένουμε το νήμα που αναλύει την $E_1$, καθώς η υποέκφραση αυτή έχει προτεραιότητα.

Συνεπώς, η κύρια διεργασία που έχει αναλάβει την ανάλυση της έκφρασης $E$ θα πρέπει να καλέσει ξεχωριστά νήματα-εργάτες για κάθε υποέκφραση, αλλά να τηρήσει την ιεραρχία:

\begin{description}[font=$\bullet$\scshape\bfseries]
	\item Πρώτα περιμένει να ολοκληρώσει το νήμα της $E_1$.
	\item Αν επιτύχει, τότε στέλνει σήμα στα υπόλοιπα νήματα να επιστρέψουν.
	\item Αλλιώς, περιμένει να τελειώσει το δεύτερο νήμα.
	\item Η διαδικασία συνεχίζεται μέχρις ότου κάποιο νήμα επιστρέψει επιτυχώς (οπότε τερματίζονται τα 
			επόμενα στην ιεραρχία, είτε αν επιστρέψουν όλα τα νήματα ανεπιτυχώς. % TODO: fix indent
\end{description}

Αν όλα επιστρέψουν ανεπιτυχώς, τότε και το κύριο νήμα που τα κάλεσε επιστρέφει ανεπιτυχώς και θέτει τη θέση στην είσοδο, όπως ήταν στην αρχή (reset).
Αλλιώς, το πρώτο νήμα στην ιεραρχία που πέτυχε καθορίζει και από ποιο σημείο της εισόδου θα συνεχίσει η ανάλυση.

\section{Packrat Parsing με Κυλιόμενο Παράθυρο}

\section{Παράλληλο Packrat Parsing με Κυλιόμενο Παράθυρο}
