diff --git a/transcript/packrat_gen.tex b/transcript/packrat_gen.tex
index f35248e..5396769 100644
--- a/transcript/packrat_gen.tex
+++ b/transcript/packrat_gen.tex
@@ -1,18 +1,18 @@
 \chapter{ Γεννήτορας Συντακτικών Αναλυτών Packrat }
 \label{ch:packrat_gen}
 
-Στο προηγούμενο κεφάλαιο, περιγράψαμε πώς λειτουργεί ένας packrat parser, καθώς και πώς θα μπορούσαμε να τον μοντελοποιήσουμε. 
+Στο προηγούμενο κεφάλαιο, περιγράψαμε πώς λειτουργεί ένας packrat parser, καθώς και πώς θα μπορούσαμε να τον μοντελοποιήσουμε.
 Βέβαια, δεν μας ενδιαφέρει απλά να ξέρουμε πώς τον κατασκευάζουμε με το χέρι, αλλά και το πώς θα μπορούσαμε να κατασκευάσουμε ένα εργαλείο που θα παίρνει ως είσοδο μία τυπική περιγραφή της γραμματικής, και θα δίνει ως έξοδο έναν συντακτικό αναλυτή για αυτήν.
 Πρακτικά, θέλουμε έναν \textit{μεταγλωττιστή-μεταγλωττιστή (compiler-compiler)}, όπως το εργαλείο YACC στον κόσμο της C. Δηλαδή, έναν γεννήτορα συντακτικών αναλυτών.
 
 To πλεονέκτημα που θα προσέφερε ένα τέτοιο εργαλείο, είναι πως θα μπορούσε να παίρνει ως είσοδο γραμματικές που έχουν, για παράδειγμα, αριστερή αναδρομή (η οποία δεν υποστηρίζεται από τις κλασικές PEGs), και να τις μετατρέπει εσωτερικά σε δεξιά αναδρομικές \cite{Ford2002a}.
-Ακόμη, επιτρέπει στον σχεδιαστή μίας γλώσσας να επικεντρωθεί στις υψηλού επιπέδου λεπτομέρειες της γραμματικής, χωρίς το φόρτο της διαρκούς υλοποίησης του αναλυτή με το χέρι. 
+Ακόμη, επιτρέπει στον σχεδιαστή μίας γλώσσας να επικεντρωθεί στις υψηλού επιπέδου λεπτομέρειες της γραμματικής, χωρίς το φόρτο της διαρκούς υλοποίησης του αναλυτή με το χέρι.
 Τέλος, δίνει τη δυνατότητα με αυτόματο τρόπο να μπορούμε να επεξεργαζόμαστε τις γραμματικές σε υψηλό επίπεδο (π.χ. να ελέγξουμε με κάποιο εργαλείο ότι οι κανόνες δεν έχουν κάποια κυκλική αναφορά), ενώ επιτρέπει και την εύκολη επαναχρησιμοποίηση κανόνων σε διάφορες γραμματικές.
 
 Αυτό που αλλάζει από γραμματική σε γραμματική για τον parser μας είναι η μοντελοποίηση της γραμματικής που ενθυλακώνει, όπως δείξαμε στο προηγούμενο κεφάλαιο.
 Δηλαδή, για να γεννήσουμε αυτόματα έναν packrat parser, αρκεί να γενήσσουμε τη μοντελοποίση της γραμματικής που θέλουμε να αναλύσει, οπότε είναι σαν να δημιουργήσαμε και τον ίδιο.
 
-Η διαδικασία που θα περιγράψουμε σε αυτό το κεφάλαιο συνοψίζεται στο Σχήμα \ref{fig:peg_factory_pipeline}. 
+Η διαδικασία που θα περιγράψουμε σε αυτό το κεφάλαιο συνοψίζεται στο Σχήμα \ref{fig:peg_factory_pipeline}.
 
 \begin{figure}[h]
 \begin{tikzpicture}[node distance=2.0cm,
@@ -44,16 +44,16 @@ To πλεονέκτημα που θα προσέφερε ένα τέτοιο ε
 \label{fig:peg_factory_pipeline}
 \end{figure}
 
-Έστω ότι θέλουμε να αναλύσουμε συντακτικά ένα πρόγραμμα Arrays.java. 
+Έστω ότι θέλουμε να αναλύσουμε συντακτικά ένα πρόγραμμα Arrays.java.
 Αρχικά, θεωρούμε ότι διαθέτουμε μία τυπική περιγραφή της γραμματικής Java, εκφρασμένης ως parsing expression grammar, μέσα σε ένα .txt αρχείο.
-Αυτή η περιγραφή αναλύεται από έναν "Meta parser" και κατασκευάζεται το συντακτικό της δέντρο (AST). 
+Αυτή η περιγραφή αναλύεται από έναν "Meta parser" και κατασκευάζεται το συντακτικό της δέντρο (AST).
 Ακολούθως, το δέντρο αυτό τροφοδοτείται σε έναν γεννήτορα γραμματικών PEG (PEG Factory), ο οποίος διασχίζει το δέντρο και γεννάει μία PEG για Java προγράμματα.
 Πρακτικά, είναι σαν να γεννάει και έναν packrat parser για Java προγράμματα, αφού είπαμε ότι ο parser ενθυλακώνει τη γραμματική που θα αναλύσει.
 Άρα, αν έχουμε ένα στιγμιότυπο της Java γραμματικής, σε μορφή PEG, μπορούμε να φτιάξουμε και το αντίστοιχο στιγμιότυπο και για τον συντακτικό αναλυτή.
 Πλέον, μπορούμε να τροφοδοτήσουμε το Arrays.java στον νέο packrat parser.
 
 \section{Τυπική Περιγραφή Γραμματικών}
-Είπαμε ότι ως είσοδο στο γεννήτορα συντακτικών αναλυτών θα δίνουμε μία τυπική περιγραφή μίας γραμματικής. 
+Είπαμε ότι ως είσοδο στο γεννήτορα συντακτικών αναλυτών θα δίνουμε μία τυπική περιγραφή μίας γραμματικής.
 Πώς, όμως, ορίζεται μία τέτοια περιγραφή? Στο Σχήμα \ref{fig:peg_specification}, παρουσιάζεται η συντακτική περιγραφή μίας PEG εκφρασμένης σε τυπική περιγραφή PEG \cite{lgi}.
 
 \begin{figure}[h]
@@ -73,22 +73,22 @@ Primary    <- Identifier !LEFTARROW                             # Type 6
 \label{fig:peg_specification}
 \end{figure}
 
-Δηλαδή, μία PEG (κανόνας $Grammar$) αποτελείται από διαδοχικούς ορισμούς (κανόνας $Definition$). 
-Ο κάθε ορισμός αποτελείται από ένα μη τερματικό (κανόνας $Identifier$), ένα αριστερό βέλος ($LEFTARROW$) και μία έκφραση (κανόνας $Expression$) κ.ό.κ.
+Δηλαδή, μία PEG (κανόνας $\mathsf{Grammar}$) αποτελείται από διαδοχικούς ορισμούς (κανόνας $\mathsf{Definition}$).
+Ο κάθε ορισμός αποτελείται από ένα μη τερματικό (κανόνας $\mathsf{Identifier}$), ένα αριστερό βέλος ($\mathsf{LEFTARROW}$) και μία έκφραση (κανόνας $\mathsf{Expression}$) κ.ό.κ.
 
 Το Σχήμα \ref{fig:peg_specification} περιγράφει μόνο τη συντακτική δομή, και όχι το πώς κατασκευάζονται οι λέξεις (tokens) μίας γραμματικής PEG.
 H πλήρης περιγραφή γίνεται στο Παράρτημα Α.
 
-Η είσοδος στο γεννήτορά μας είναι πλέον έτοιμη. 
+Η είσοδος στο γεννήτορά μας είναι πλέον έτοιμη.
 Πρακτικά, είναι ένα αρχείο κειμένου που θα περιγράφει τη γραμματική μίας γλώσσας (Java, XML, κλπ.) σε PEG τυπική μορφή.
 
 \section{Στιγμιότυπο μίας μετα-γραμματικής που περιγράφει Parsing Expresssion Grammars}
 
-Έχοντας έτοιμη την είσοδο της τυπικής περιγραφής, χρειαζόμαστε έναν μετα-αναλυτή για να την αναλύσει, όπως περιγράψαμε στο Σχήμα \ref{fig:peg_factory_pipeline}. 
+Έχοντας έτοιμη την είσοδο της τυπικής περιγραφής, χρειαζόμαστε έναν μετα-αναλυτή για να την αναλύσει, όπως περιγράψαμε στο Σχήμα \ref{fig:peg_factory_pipeline}.
 Το στιγμιότυπο αυτής της γραμματικής αναγκαστικά πρέπει να φτιαχτεί "με το χέρι".
 Δηλαδή, να δημιουργήσουμε τα κατάλληλα αντικείμενα που απαρτίζουν τις εκφράσεις και τους κανόνες μίας τέτοιας γραμματικής.
 
-Ενδεικτικά, στο Σχήμα \ref{fig:meta_example}, παραθέτουμε τον κώδικα για τη δημιουργία του πρώτου κανόνα της μετα-γραμματικής, που λέει ότι μία PEG αποτελείται από ένα σύνολο διαδοχικών κανόνων (definitions). O τελεστής της "ακολουθίας" θεωρούμε ότι είναι ο χαρακτήρας `$\backslash b$'. 
+Ενδεικτικά, στο Σχήμα \ref{fig:meta_example}, παραθέτουμε τον κώδικα για τη δημιουργία του πρώτου κανόνα της μετα-γραμματικής, που λέει ότι μία PEG αποτελείται από ένα σύνολο διαδοχικών κανόνων (definitions). O τελεστής της "ακολουθίας" θεωρούμε ότι είναι ο χαρακτήρας `$\backslash b$'.
 
 \begin{figure}[h]
 \setlength\partopsep{-\topsep}% adjusts vertical space after the listing
@@ -111,8 +111,8 @@ this->push_rule(&grammar, &grammarExp);
 
 \section{Γεννήτορας συντακτικών αναλυτών packrat}
 
-Συνεχίζοντας το σκεπτικό του Σχήματος \ref{fig:peg_factory_pipeline}, έχοντας κατασκευάσει τη μετα-γραμματική, της δίνουμε ως είσοδο μία τυπική περιγραφή της γραμματικής-στόχου (π.χ. ένα .txt αρχείο). 
-Το αποτέλεσμα είναι το Αφηρημένο Συντακτικό Δέντρο (AST). 
+Συνεχίζοντας το σκεπτικό του Σχήματος \ref{fig:peg_factory_pipeline}, έχοντας κατασκευάσει τη μετα-γραμματική, της δίνουμε ως είσοδο μία τυπική περιγραφή της γραμματικής-στόχου (π.χ. ένα .txt αρχείο).
+Το αποτέλεσμα είναι το Αφηρημένο Συντακτικό Δέντρο (AST).
 Σε αυτή την ενότητα περιγράφουμε πώς ένας γεννήτορας γραμματικών peg (peg factory), παίρνει ως είσοδο το AST και δίνει ως έξοδο την αντίστοιχη peg.
 
 Η βασική ιδέα είναι ότι οι κόμβοι του AST έχουν ονόματα τα οποία δείχνουν σε ποιο μη τερματικό της μετα-γραμματικής αντιστοιχούν.
@@ -180,7 +180,7 @@ Expression* construct_sequence(TreeNode* node)
 Οπότε, ο κώδικας λέει πως αν ο κόμβος έχει πάνω από ένα παιδί, τότε δημιούργησε ένα CompositeExpression ακολουθίας με όλα αυτά τα παιδιά ως μη τερματικά.
 Αλλιώς, επίστρεψε απλά το μη τερματικό του μοναδικού παιδιού.
 
-Τελικά, για το παράδειγμά μας, τα στιγμιότυπα που θα γεννιούνταν θα ήταν όπως στο Σχήμα \ref{fig:objects_seq_example}. 
+Τελικά, για το παράδειγμά μας, τα στιγμιότυπα που θα γεννιούνταν θα ήταν όπως στο Σχήμα \ref{fig:objects_seq_example}.
 
 \begin{figure}[h]
 \setlength\partopsep{-\topsep}% adjusts vertical space after the listing
@@ -205,4 +205,3 @@ this->push_rule(&parent, &grammarExp);
 Από αυτήν έχουμε αυτομάτως και τον αντίστοιχο Java packrat parser.
 To τελευταίο βήμα για  τη διαδικασία του Σχήματος \ref{fig:peg_factory_pipeline}, είναι να δώσουμε ως είσοδο στον Java packrat parser ένα αρχείο Java.
 Έτσι, παίρνουμε το AST για το .java αρχείο, οπότε ο στόχος μας επιτεύχθηκε.
-
diff --git a/transcript/thesis.tex b/transcript/thesis.tex
index d9a0229..a4866a3 100644
--- a/transcript/thesis.tex
+++ b/transcript/thesis.tex
@@ -65,6 +65,9 @@
 \newcolumntype{a}{>{\columncolor{Gray}}c}
 \newcolumntype{b}{>{\columncolor{white}}c}
 
+\usepackage{todonotes}
+\newcommand\TODO[1]{\todo[inline, color=yellow]{TODO:\quad#1}}
+
 %%%
 %%%  The document
 %%%
@@ -86,12 +89,12 @@
 
 \committeeone{Νικόλαος Σ. Παπασπύρου}
 \committeeonepos{Καθηγητής Ε.Μ.Π.}
-\committeetwo{Δημήτρη Φωτάκης}
+\committeetwo{Δημήτρης Φωτάκης}
 \committeetwopos{Αν. Καθηγητής Ε.Μ.Π.}
 \committeethree{Γεώργιος Γκούμας}
 \committeethreepos{Επικ. Καθηγητής Ε.Μ.Π.}
 
-\TRnumber{CSD-SW-TR-42-17}  % number-year, ask nickie for the number
+\TRnumber{CSD-SW-TR-1-20}
 \department{Τομέας Τεχνολογίας Πληροφορικής και Υπολογιστών}
 
 \maketitle
@@ -100,6 +103,8 @@
 %%%  Abstract, in Greek
 
 \begin{abstractgr}%
+  \TODO{Μία εισαγωγική παράγραφος για parsing και packrat parsing.}
+
   Σκοπός της παρούσας εργασίας είναι αφενός η υλοποίηση ενός συντακτικού αναλυτή
   packrat στη κλασική του μορφή, αφετέρου η βελτίωση της επίδοσής του είτε
   τροποποιώντας τον αρχικό αλγόριθμο, είτε παραλληλοποιώντας τον ώστε να τρέξει
@@ -116,6 +121,8 @@
 %%%  Abstract, in English
 
 \begin{abstracten}%
+  \TODO{Μία εισαγωγική παράγραφος για parsing και packrat parsing.}
+
   The purpose of this diploma dissertation is on one hand the implementation
   of a packrat parser in its original version, and on the other hand to improve
   its performance, either through modifications to the standard version of the algorithm,
@@ -139,7 +146,7 @@
 
 \begin{acknowledgementsen}
   I would like to thank all the people who supported my work and helped me get
-  results of better quality.  
+  results of better quality.
 \end{acknowledgementsen}
 
 
@@ -206,19 +213,19 @@ Primary    <- Identifier !LEFTARROW                             # Type 6
 # Lexical syntax
 
 Identifier <- IdentifierStart IdentifierRest* Spacing
-IdentifierStart <- 'a' / 'b' / 'c' / 'd' / 'e' / 'f' / 'g' / 'h' / 
-		   'i' / 'j' / 'k' / 'l' / 'm' / 'n' / 'o' / 'p' / 
-		   'q' / 'r' / 's' / 't' / 'u' / 'v' / 'w' / 'x' / 'y' / 'z' / 
-		   ᾽A' / 'B' / 'C' / 'D' / 'E' / 'F' / 'G' / 'H' / 
-		   'I' / 'J' / 'K' / 'L' / 'M' / 'N' / 'O' / 'P' / 
+IdentifierStart <- 'a' / 'b' / 'c' / 'd' / 'e' / 'f' / 'g' / 'h' /
+		   'i' / 'j' / 'k' / 'l' / 'm' / 'n' / 'o' / 'p' /
+		   'q' / 'r' / 's' / 't' / 'u' / 'v' / 'w' / 'x' / 'y' / 'z' /
+		   ᾽A' / 'B' / 'C' / 'D' / 'E' / 'F' / 'G' / 'H' /
+		   'I' / 'J' / 'K' / 'L' / 'M' / 'N' / 'O' / 'P' /
 		   'Q' / 'R' / 'S' / 'T' / 'U' / 'V' / 'W' / 'X' / 'Y' / 'Z' / '_'
 
-IdentifierRest <- 'a' / 'b' / 'c' / 'd' / 'e' / 'f' / 'g' / 'h' / 
-		  'i' / 'j' / 'k' / 'l' / 'm' / 'n' / 'o' / 'p' / 
-		  'q' / 'r' / 's' / 't' / 'u' / 'v' / 'w' / 'x' / 'y' / 'z' / 
-		  'A' / 'B' / 'C' / 'D' / 'E' / 'F' / 'G' / 'H' / 
-		  'I' / 'J' / 'K' / 'L' / 'M' / 'N' / 'O' / 'P' / 
-		  'Q' / 'R' / 'S' / 'T' / 'U' / 'V' / 'W' / 'X' / 'Y' / 'Z' / '_' / 
+IdentifierRest <- 'a' / 'b' / 'c' / 'd' / 'e' / 'f' / 'g' / 'h' /
+		  'i' / 'j' / 'k' / 'l' / 'm' / 'n' / 'o' / 'p' /
+		  'q' / 'r' / 's' / 't' / 'u' / 'v' / 'w' / 'x' / 'y' / 'z' /
+		  'A' / 'B' / 'C' / 'D' / 'E' / 'F' / 'G' / 'H' /
+		  'I' / 'J' / 'K' / 'L' / 'M' / 'N' / 'O' / 'P' /
+		  'Q' / 'R' / 'S' / 'T' / 'U' / 'V' / 'W' / 'X' / 'Y' / 'Z' / '_' /
 		  '0' / '1' / '2' / '3' / '4' / '5' / '6' / '7' / '8' / '9'
 
 Literal    <- "'" (!"'" Character)* "'" Spacing                 # Type 8
@@ -228,7 +235,7 @@ Character  <- ('\\' ('n' / 'r' / 't' / '\\' / "'" / '"' / UnicodeEscape)) / (!'\
 
 UnicodeEscape <- 'u' UnicodeElement UnicodeElement UnicodeElement UnicodeElement
 
-UnicodeElement <- '0' / '1' / '2'/ '3' / '4' / '5' / '6' / '7' / '8' / '9' / 
+UnicodeElement <- '0' / '1' / '2'/ '3' / '4' / '5' / '6' / '7' / '8' / '9' /
 		  'A' / 'B' / 'C' / 'D'/ 'E' / 'F' / 'a' / 'b' / 'c' / 'd'/ 'e' / 'f'
 
 
