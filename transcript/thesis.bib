Automatically generated by Mendeley Desktop 1.19.4
Any changes to this file will be lost if it is regenerated by Mendeley.

BibTeX export options can be customized via Options -> BibTeX in Mendeley Desktop

@book{Aho2007,
abstract = {This book provides the foundation for understanding the theory and pracitce of compilers. Revised and updated, it reflects the current state of compilation. Every chapter has been completely revised to reflect developments in software engineering, programming languages, and computer architecture that have occurred since 1986, when the last edition published. The authors, recognizing that few readers will ever go on to construct a compiler, retain their focus on the broader set of problems faced in software design and software development. Computer scientists, developers, and aspiring students that want to learn how to build, maintain, and execute a compiler for a major programming language.},
author = {Aho, A and Lam, M and Sethi, R and Ullman, JD},
file = {:home/blackgeorge/documents/ebooks/Compilers/Compilers (Principles, Techniques, and Tools) [Aho,Lam,Sethi].pdf:pdf},
isbn = {0321486811},
pages = {1038},
title = {{Compilers: Principles, Techniques, and Tools}},
url = {http://scholar.google.com/scholar?hl=en{\&}btnG=Search{\&}q=intitle:Compilers+Principles,+Techniques,+{\&}+Tools{\#}0{\%}5Cnhttp://scholar.google.com/scholar?hl=en{\&}btnG=Search{\&}q=intitle:Compilers:+Principles,+Techniques,+and+Tools{\#}0},
year = {2007}
}
@article{Ford2004a,
abstract = {For decades we have been using Chomsky's generative system of grammars, particularly context-free grammars (CFGs) and regular expressions (REs), to express the syntax of programming languages and protocols. The power of generative grammars to express ambiguity is crucial to their original purpose of modelling natural languages, but this very power makes it unnecessarily difficult both to express and to parse machine-oriented languages using CFGs. Parsing Expression Grammars (PEGs) provide an alternative, recognition-based formal foundation for describing machine-oriented syntax, which solves the ambiguity problem by not introducing ambiguity in the first place. Where CFGs express nondeterministic choice between alternatives, PEGs instead use prioritized choice. PEGs address frequently felt expressiveness limitations of CFGs and REs, simplifying syntax definitions and making it unnecessary to separate their lexical and hierarchical components. A linear-time parser can be built for any PEG, avoiding both the complexity and fickleness of LR parsers and the inefficiency of generalized CFG parsing. While PEGs provide a rich set of operators for constructing grammars, they are reducible to two minimal recognition schemas developed around 1970, TS/TDPL and gTS/GTDPL, which are here proven equivalent in effective recognition power.},
author = {Ford, Bryan},
doi = {10.1145/982962.964011},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Ford - 2004 - Parsing expression grammars A recognition-based syntactic foundation.pdf:pdf},
isbn = {158113729X},
issn = {07308566},
journal = {Conference Record of the Annual ACM Symposium on Principles of Programming Languages},
keywords = {BNF,Context-free grammars,GTDPL,Lexical analysis,Packrat parsing,Parsing expression grammars,Regular expressions,Scannerless parsing,Syntactic predicates,TDPL,Unified grammars},
pages = {111--122},
title = {{Parsing expression grammars: A recognition-based syntactic foundation}},
volume = {31},
year = {2004}
}
@article{Ford2002b,
abstract = {Packrat parsing is a novel technique for implementing parsers in a lazy functional programming language. A packrat parser provides the power and flexibility of top-down parsing with backtracking and unlimited lookahead, but nevertheless guarantees linear parse time. Any language defined by an LL(k) or LR(k) grammar can be recognized by a packrat parser, in addition to many languages that conventional linear-time algorithms do not support. This additional power simplifies the handling of common syntactic idioms such as the widespread but troublesome longest-match rule, enables the use of sophisticated disambiguation strategies such as syntactic and semantic predicates, provides better grammar composition properties, and allows lexical analysis to be integrated seamlessly into parsing. Yet despite its power, packrat parsing shares the same simplicity and elegance as recursive descent parsing; in fact converting a back-tracking recursive descent parser into a linear-time packrat parser often involves only a fairly straightforward structural change. This paper describes packrat parsing informally with emphasis on its use in practical applications, and explores its advantages and disadvantages with respect to the more conventional alternatives.},
author = {Ford, Bryan},
doi = {10.1145/583852.581483},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Ford - 2002 - Packrat parsing Simple, powerful, lazy, linear time - Functional pearl.pdf:pdf},
isbn = {1581134878},
issn = {0362-1340},
journal = {Proceedings of the ACM SIGPLAN International Conference on Functional Programming, ICFP},
keywords = {all or part of,analysis,backtracking,haskell,lexical,memoization,or,or hard copies of,parser combinators,permission to make digital,scannerless parsing,this work for personal,top-down parsing},
pages = {36--47},
title = {{Packrat parsing: Simple, powerful, lazy, linear time - Functional pearl}},
year = {2002}
}
@article{Ford2002c,
abstract = {Packrat parsing is a novel and practical method for implementing linear-time parsers for grammars defined in Top-Down Parsing Language (TDPL). While TDPL was originally created as a formal model for top-down parsers with backtracking capability, this thesis extends TDPL into a powerful general-purpose notation for describing language syntax, providing a compelling alternative to traditional context-free grammars (CFGs). Common syntactic idioms that cannot be represented concisely in a CFG are...},
author = {Ford, Bryan},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Ford - 2002 - Packrat Parsing a Practical Linear-Time Algorithm with Backtracking by.pdf:pdf},
journal = {Proceedings of the International Conference on Functional Programming ICFP 2002},
title = {{Packrat Parsing : a Practical Linear-Time Algorithm with Backtracking by}},
url = {http://scholar.google.com/scholar?hl=en{\&}btnG=Search{\&}q=intitle:Packrat+Parsing:+a+Practical+Linear-Time+Algorithm+with+Backtracking{\#}0},
year = {2002}
}
@article{Skrzypczak2011a,
author = {Skrzypczak, Piotr},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Skrzypczak - 2011 - Parallel parsing of context-free grammars.pdf:pdf},
keywords = {BTH, 2011, COM, School of Computing, Computer Scie},
number = {December},
title = {{Parallel parsing of context-free grammars}},
year = {2011}
}
@article{Grimma,
author = {Grimm, Robert},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Grimm - Unknown - Practical Packrat Parsing Categories and Subject Descriptors.pdf:pdf},
keywords = {a considerable number of,ex-,extensible programming languages,packrat,parser generators,parsers,parsing expression grammars,research projects have been},
title = {{Practical Packrat Parsing Categories and Subject Descriptors}},
url = {http://cs1.cs.nyu.edu/rgrimm/papers/tr2004-854.pdf}
}
@article{Redziejowski2011a,
abstract = {In an earlier paper, the author adapted to Parsing Expression Grammars (PEGs) the properties FIRST and FOLLOW used in the construction of predictive top-down parsers. The purpose was to obtain warnings for possible "language hiding". It turned out that FIRST does not work well with lookahead expressions. To repair this, it is replaced here by a property named BITES that is a set of input strings instead of terminals.},
author = {Redziejowski, Roman R.},
doi = {10.3233/FI-2011-514},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Redziejowski - 2011 - BITES instead of FIRST for parsing expression grammar.pdf:pdf},
issn = {01692968},
journal = {Fundamenta Informaticae},
number = {3},
pages = {323--337},
title = {{BITES instead of FIRST for parsing expression grammar}},
volume = {109},
year = {2011}
}
@article{Mascarenhasa,
abstract = {Parsing Expression Grammars (PEGs) are a formalism for language recognition that renewed academic interest in top-down parsing approaches. LPEG is an implementation of the PEG formalism which compiles PEGs to instructions of a virtual parsing machine, preserving PEG semantics. The LPEG parsing machine has a formal model, and the transformation of PEGs to this model has been proven correct. In this paper, we extend both the PEG formalism and LPEG's parsing machine so they can match structured data instead of just strings of symbols. Our extensions are conservative, and we prove the correctness of the translation from extended PEGs to programs of the extended parsing machine. We also present benchmarks that show that the performance of the extended parsing machine for structured data is competitive with the performance of equivalent hand-written parsers.},
author = {Mascarenhas, Fabio and Medeiros, S and Ierusalimschy, Roberto},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Mascarenhas, Medeiros, Ierusalimschy - Unknown - Parsing Expression Grammars for Structured Data.pdf:pdf},
journal = {Lbd.Dcc.Ufmg.Br},
keywords = {natural semantics,parsing expression grammars,parsing machine,pattern matching,tree grammars},
title = {{Parsing Expression Grammars for Structured Data}},
url = {http://www.lbd.dcc.ufmg.br/colecoes/sblp/2011/003.pdf}
}
@article{Becket2007a,
abstract = {Packrat parsing is a newly popular technique for efficiently implementing recursive descent parsers. Packrat parsing avoids the potential exponential costs of recursive descent parsing with backtracking by ensuring that each production rule in the grammar is tested at most once against each position in the input stream. This paper argues that (a) packrat parsers can be trivially implemented using a combination of definite clause grammar rules and memoing, and that (b) packrat parsing may actually be significantly less efficient than plain recursive descent with backtracking, but (c) memoing the recognizers of just one or two nonterminals, selected in accordance with Amdahl's law, can sometimes yield speedups. We present experimental evidence to support these claims. {\textcopyright} Springer-Verlag Berlin Heidelberg 2008.},
author = {Becket, Ralph and Somogyi, Zoltan},
doi = {10.1007/978-3-540-77442-6_13},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Becket, Somogyi - 2007 - DCGs Memoing = Packrat parsing but is it worth it.pdf:pdf},
isbn = {3540774416},
issn = {03029743},
journal = {Lecture Notes in Computer Science (including subseries Lecture Notes in Artificial Intelligence and Lecture Notes in Bioinformatics)},
keywords = {DCG,Memoing,Mercury,Packrat,Parsing,Recursive descent,Tabling},
number = {1},
pages = {182--196},
title = {{DCGs + Memoing = Packrat parsing but is it worth it?}},
volume = {4902 LNCS},
year = {2007}
}
@article{Redziejowski2016a,
abstract = {Parsing Expression Grammar (PEG) encodes a recursive-descent parser with limited backtracking. It has been recently noticed that in the situation when the parser is to explore several alternatives one after another, no further alternatives need to be explored after the parser reached certain "cut point". This fact can be used to save both processing time and storage. The subject of the paper is identification of cut points, which can also help in producing better diagnostics.},
author = {Redziejowski, Roman R.},
doi = {10.3233/FI-2016-1308},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Redziejowski - 2016 - Cut Points in PEG.pdf:pdf},
issn = {01692968},
journal = {Fundamenta Informaticae},
number = {1-2},
pages = {141--149},
title = {{Cut Points in PEG}},
volume = {143},
year = {2016}
}
@article{Sugimoto2018a,
abstract = {Packrat parsing is a recursive descent parsing method with backtracking and memoization. Parsers based on this method require no separate lexical analyzers, and backtracking enables those parsers to handle a wide range of complex syntactic constructs. Memoization is used to prevent exponential growth of running time, resulting in linear time complexity at th cost of linear space consumption. In this study, we propose CPEG – a library that can be used to write parsers using Packrat parsing in C language. This library enables programmers to describe syntactic rules in an internal domain-specific language (DSL) which, unlike parser combinators, does not require runtime data structures to represent syntax. Syntax rules are just expressed by plain C macros. The runtime routine does not dynamically allocate memory regions for memoization. Instead, statically allocated arrays are used as memoization cache tables. Therefore, programmers can implement practical parsers with CPEG, which does not depend on any specific memory management features, requiring fixed-sized memory (except for input string). To enhance usability, a translator to CPEG from an external DSL is provided, as well as a tuning mechanism to control memoization parameters. Parsing time compared to other systems when parsing JavaScript Object Notation and Java source files are given. The experimental results indicate that the performance of CPEG is competitive with other libraries.},
author = {Sugimoto, Yuta and Maeda, Atusi},
doi = {10.2197/ipsjjip.26.335},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Sugimoto, Maeda - 2018 - Implementation of C library for constructing packrat parser with statically allocated memory.pdf:pdf},
issn = {18826652},
journal = {Journal of Information Processing},
keywords = {C language,DSL,Packrat parsing,Parsing},
pages = {335--344},
title = {{Implementation of C library for constructing packrat parser with statically allocated memory}},
volume = {26},
year = {2018}
}
@article{Bilka2012a,
abstract = {Top-down parsing has received much attention recently. Parsing expression grammars (PEG) allows construction of linear time parsers using packrat algorithm. These techniques however suffer from problem of prefix hiding. We use alternative formalism of relativized regular expressions REGREG for which top-down backtracking parser runs in linear time. This formalism allows to construct fast parsers with modest memory requirements for practical grammars. We show that our formalism is equivalent to PEG.},
archivePrefix = {arXiv},
arxivId = {1205.1877},
author = {B{\'{i}}lka, Ondřej},
eprint = {1205.1877},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/B{\'{i}}lka - 2012 - Structured Grammars are Effective.pdf:pdf},
pages = {1--15},
title = {{Structured Grammars are Effective}},
url = {http://arxiv.org/abs/1205.1877},
year = {2012}
}
@article{Tota2013a,
abstract = {In the field of formal languages apart from context free grammar (CFG) a new approach is developed i.e. Parsing Expression Grammar (PEG). Parsing Expression Grammar (PEG) is a new way to specify recursive-descent parsers with limited backtracking. The use of backtracking lifts the LL(1) restriction usually imposed by top-down parsers. In addition, PEG can directly define the structures that usually require a separate " lexer " or " scanner " . The parser has many useful properties, and with the use of memorization, it works in a linear time. This paper reports an experiment that consisted of defining PEG formalism, and literally transcribing the PEG definitions into parsing procedures.},
author = {Tota, Madhavi and {Pradeep Kumar}, P},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Tota, Pradeep Kumar - 2013 - Parser Generator for Parsing Expression Grammar.pdf:pdf},
journal = {Compusoft},
keywords = {CFG,PEG,backtracking,lexer,memorization},
number = {7},
pages = {188--192},
title = {{Parser Generator for Parsing Expression Grammar}},
volume = {2},
year = {2013}
}
@article{Henglein2017a,
abstract = {Tabular top-down parsing and its lazy variant, Packrat, are lineartime execution models for the TDPL family of recursive descent parsers with limited backtracking. Exponential work due to backtracking is avoided by tabulating the result of each (nonterminal, offset)-pair at the expense of always using space proportional to the product of the input length and grammar size. Current methods for limiting the space usage rely either on manual annotations or on static analyses that are sensitive to the syntactic structure of the grammar. We present progressive tabular parsing (PTP), a new execution model which progressively computes parse tables for longer prefixes of the input and simultaneously generates a leftmost expansion of the parts of the parse tree that can be resolved. Table columns can be discarded on-the-fly as the expansion progresses through the input string, providing best-case constant and worst-case linear memory use. Furthermore, semantic actions are scheduled before the parser has seen the end of the input. The scheduling is conservative in the sense that no action has to be "undone" in the case of backtracking. The time complexity is O(dmn) where m is the size of the parser specification, n is the size of the input string, and d is either a configured constant or the maximum parser stack depth. For common data exchange formats such as JSON, we demonstrate practically constant space usage.},
author = {Henglein, Fritz and Rasmussen, Ulrik Terp},
doi = {10.1145/3018882.3018889},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Henglein, Rasmussen - 2017 - PEG parsing in less space using progressive tabling and dynamic analysis.pdf:pdf},
isbn = {9781450347211},
journal = {PEPM 2017 - Proceedings of the 2017 ACM SIGPLAN Workshop on Partial Evaluation and Program Manipulation, co-located with POPL 2017},
keywords = {Context-free grammars,Packrat,Parsing expression grammars,Regular expressions,Streaming parsing},
pages = {35--46},
title = {{PEG parsing in less space using progressive tabling and dynamic analysis}},
year = {2017}
}
@article{Flodin2014a,
author = {Flodin, Daniel},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Flodin - 2014 - A Comparison Between Packrat Parsing and Conventional Shift-Reduce Parsing on Real-World Grammars and Inputs.pdf:pdf},
title = {{A Comparison Between Packrat Parsing and Conventional Shift-Reduce Parsing on Real-World Grammars and Inputs}},
year = {2014}
}
@article{Johnson2011b,
abstract = {• Direct translation into CUDA ran 200× slower than unparallelised CPU version• Recoded algorithm to exploit:▶ global memory (slow but accessible to all blocks; stores Chart)▶ texture memory (faster but read-only; stores Rule)▶ shared memory (accessible to all ...},
author = {Johnson, Mark},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Johnson - 2011 - Parsing in parallel on multiple cores and gpus.pdf:pdf},
journal = {Proceedings of the Australasian Language {\ldots}},
number = {December},
pages = {29--37},
title = {{Parsing in parallel on multiple cores and gpus}},
url = {http://aclweb.org/anthology/U/U11/U11-1006.pdf{\%}0Ahttp://web.science.mq.edu.au/{~}mjohnson/papers/Johnson11ALTA-parallel-parsing-talk.pdf},
year = {2011}
}
@article{Johnson2011c,
abstract = {• Direct translation into CUDA ran 200× slower than unparallelised CPU version• Recoded algorithm to exploit:▶ global memory (slow but accessible to all blocks; stores Chart)▶ texture memory (faster but read-only; stores Rule)▶ shared memory (accessible to all ...},
author = {Johnson, Mark},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Johnson - 2011 - Parsing in parallel on multiple cores and gpus(2).pdf:pdf},
journal = {Proceedings of the Australasian Language {\ldots}},
pages = {29--37},
title = {{Parsing in parallel on multiple cores and gpus}},
url = {http://aclweb.org/anthology/U/U11/U11-1006.pdf{\%}0Ahttp://web.science.mq.edu.au/{~}mjohnson/papers/Johnson11ALTA-parallel-parsing-talk.pdf},
year = {2011}
}
@article{Valiant1990a,
author = {Valiant, Leslie},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Valiant - 1990 - Leslie 6. Valiant 103.pdf:pdf},
journal = {Communications of the ACM},
number = {8},
title = {{Leslie 6. Valiant 103}},
volume = {33},
year = {1990}
}
@article{1970a,
author = {الله, برهام محمد عطال},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/الله - 1970 - Alexander Birman.pdf:pdf},
isbn = {9789896540821},
title = {{Alexander Birman}},
volume = {2},
year = {1970}
}
@article{Loff2019a,
abstract = {We study the computational power of parsing expression grammars (PEGs). We begin by constructing PEGs with unexpected behaviour, and surprising new examples of languages with PEGs, including the language of palindromes whose length is a power of two, and a binary-counting language. We then propose a new computational model, the scaffolding automaton, and prove that it exactly characterises the computational power of parsing expression grammars (PEGs). Using this characterisation we show that: (*) PEGs have unexpected power and semantics. We present several PEGs with surprising behaviour, and languages which, unexpectedly, have PEGs, including a PEG for the language of palindromes whose length is a power of two. (*) PEGs are computationally `universal', in the following sense: take any computable function {\$}f:\backslash{\{}0,1\backslash{\}}{\^{}}\backslashast\backslashto \backslash{\{}0,1\backslash{\}}{\^{}}\backslashast{\$}; then there exists a computable function {\$}g: \backslash{\{}0,1\backslash{\}}{\^{}}\backslashast \backslashto \backslashmathbb{\{}N{\}}{\$} such that {\$}\backslash{\{} f(x) \backslash{\#}{\^{}}{\{}g(x){\}} x \backslashmid x \backslashin \backslash{\{}0,1\backslash{\}}{\^{}}\backslashast \backslash{\}}{\$} has a PEG. (*) There can be no pumping lemma for PEGs. There is no total computable function {\$}A{\$} with the following property: for every well-formed PEG {\$}G{\$}, there exists {\$}n{\_}0{\$} such that for every string {\$}x \backslashin \backslashmathcal{\{}L{\}}(G){\$} of size {\$}|x| \backslashge n{\_}0{\$}, the output {\$}y = A(G, x){\$} is in {\$}\backslashmathcal{\{}L{\}}(G){\$} and has {\$}|y| {\textgreater} |x|{\$}. (*) PEGs are strongly non real-time for Turing machines. There exists a language with a PEG, such that neither it nor its reverse can be recognised by any multi-tape online Turing machine which is allowed to do only {\$}o(n/\backslashlog n){\$} steps after reading each input symbol.},
archivePrefix = {arXiv},
arxivId = {1902.08272},
author = {Loff, Bruno and Moreira, Nelma and Reis, Rog{\'{e}}rio},
eprint = {1902.08272},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Loff, Moreira, Reis - 2019 - The computational power of parsing expression grammars.pdf:pdf},
keywords = {2000 msc,68q05,68q42,68q45,context-free grammar,corresponding author,lemma,parsing expression grammar,pumping,real-time turing machine,scaffolding automata},
title = {{The computational power of parsing expression grammars}},
url = {http://arxiv.org/abs/1902.08272},
year = {2019}
}
@article{Timnat2014a,
abstract = {Lock-free data structures guarantee overall system progress, whereas wait-free data structures guarantee the progress of each and every thread, providing the desirable non-starvation guarantee for concurrent data structures. While practical lock-free implementations are known for various data structures, wait-free data structure designs are rare. Wait-free implementations have been notoriously hard to design and often inefficient. In this work we present a transformation of lock-free algorithms to wait-free ones allowing even a nonexpert to transform a lock-free data-structure into a practical wait-free one. The transformation requires that the lock-free data structure is given in a normalized form defined in this work. Using the new method, we have designed and implemented wait-free linked-list, skiplist, and tree and we measured their performance. It turns out that for all these data structures the wait-free implementations are only a few percent slower than their lock-free counterparts, while still guaranteeing non-starvation.},
author = {Timnat, Shahar and Petrank, Erez},
doi = {10.1145/2555243.2555261},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Timnat, Petrank - 2014 - A practical wait-free simulation for lock-free data structures.pdf:pdf},
isbn = {9781450326568},
issn = {15232867},
journal = {ACM SIGPLAN Notices},
keywords = {Lock-Freedom,Wait-Freedom},
number = {8},
pages = {357--368},
title = {{A practical wait-free simulation for lock-free data structures}},
volume = {49},
year = {2014}
}
@article{Mascarenhas2011a,
archivePrefix = {arXiv},
arxivId = {arXiv:1210.4992v1},
author = {Mascarenhas, Fabio and Ierusalimschy, Roberto},
eprint = {arXiv:1210.4992v1},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Mascarenhas, Ierusalimschy - 2011 - From Regular Expressions to Parsing Expression Grammars.pdf:pdf},
journal = {Brazilian Symposium on Programming Languages},
keywords = {natural,parsing expression grammars,pattern matching,regular expressions,semantics},
title = {{From Regular Expressions to Parsing Expression Grammars}},
year = {2011}
}
@article{M.2016a,
author = {M., Manish and M.M., Dr. and Latesh, Dr.},
doi = {10.14569/ijarai.2016.050305},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/M., M.M., Latesh - 2016 - Packrat Parsing A Literature Review.pdf:pdf},
issn = {21654050},
journal = {International Journal of Advanced Research in Artificial Intelligence},
keywords = {Backtracking,Memoization,Packrat Parsing,Parsing Expression Grammar,backtracking,memoization,packrat parsing,parsing expression grammar},
number = {3},
pages = {26--31},
title = {{Packrat Parsing: A Literature Review}},
volume = {5},
year = {2016}
}
@article{Dubroy2017a,
abstract = {Packrat parsing is a popular technique for implementing top-down, unlimited-lookahead parsers that operate in guaranteed linear time. In this paper, we describe a method for turning a standard packrat parser into an incremental parser through a simple modification to its memoization strategy. By "incremental", we mean that the parser can perform syntax analysis without completely reparsing the input after each edit operation. This makes packrat parsing suitable for interactive use in code editors and IDEs - even with large inputs. Our experiments show that with our technique, an incremental packrat parser for JavaScript can outperform even a hand-optimized, non-incremental parser.},
author = {Dubroy, Patrick and Warth, Alessandro},
doi = {10.1145/3136014.3136022},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Dubroy, Warth - 2017 - Incremental packrat parsing.pdf:pdf},
isbn = {9781450355254},
journal = {SLE 2017 - Proceedings of the 10th ACM SIGPLAN International Conference on Software Language Engineering, co-located with SPLASH 2017},
keywords = {Incremental parsing,Packrat parsing},
pages = {14--25},
title = {{Incremental packrat parsing}},
year = {2017}
}
@article{Vishwakarma2015a,
abstract = {Two recent developments in the field of formal languages are Parsing Expression Grammar (PEG) and packrat parsing. The PEG formalism is similar to BNF, but defines syntax in terms of recognizing strings, rather than constructing them. It is, in fact, precise specification of a backtracking recursive-descent parser. Packrat parsing is a general method to handle backtracking in recursive descent parsers. It ensures linear working time, at a huge memory cost. This paper begins with discussion of PEG and packrat parsing introduced by Bryan Ford Followed by various approaches over improvement of packrat parsing to reduce the memory requirement. This paper also describes the approaches to handle the left-recursion problem for PEG. The described Approaches handle the direct and indirect left-recursion problem for PEG. The paper concludes with the application of packrat parsing and throws a light on future scope in packrat parsing.},
author = {Vishwakarma, Amit and Goswami, Manish M and Gonnade, Priyanka},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Vishwakarma, Goswami, Gonnade - 2015 - A Survey of Packrat Parser.pdf:pdf},
keywords = {PEG,Packrat Parser,Recursive Descent Parser,TDPL},
number = {5},
pages = {324--329},
title = {{A Survey of Packrat Parser}},
volume = {5},
year = {2015}
}
@article{Redziejowski2010a,
author = {Redziejowski, Roman R},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Redziejowski - 2010 - Relations FIRST and FOLLOW for Parsing Expression Grammar What is Parsing Expression Grammar.pdf:pdf},
number = {237},
title = {{Relations FIRST and FOLLOW for Parsing Expression Grammar What is Parsing Expression Grammar ?}},
volume = {2},
year = {2010}
}
@article{Barenghi2015a,
abstract = {The property of local parsabilityallows to parse inputs through inspecting only a bounded-length string around the current token. This in turn enables the construction of a scalable, data-parallel parsing algorithm, which is presented in this work. Such an algorithm is easily amenable to be automatically generated via a parser generator tool, which was realized, and is also presented in the following. Furthermore, to complete the framework of a parallel input analysis, a parallel scanner can also combined with the parser. To prove the practicality of a parallel lexing and parsing approach, we report the results of the adaptation of JSON and Lua to a form fit for parallel parsing (i.e. an operator-precedence grammar) through simple grammar changes and scanning transformations. The approach is validated with performance figures from both high performance and embedded multicore platforms, obtained analyzing real-world inputs as a test-bench. The results show that our approach matches or dominates the performances of production-grade LR parsers in sequential execution, and achieves significant speedups and good scaling on multi-core machines. The work is concluded by a broad and critical survey of the past work on parallel parsing and future directions on the integration with semantic analysis and incremental parsing.},
author = {Barenghi, Alessandro and Reghizzi, Stefano Crespi and Mandrioli, Dino and Panella, Federica and Pradella, Matteo},
doi = {10.1016/j.scico.2015.09.002},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Barenghi et al. - 2015 - Parallel parsing made practical.pdf:pdf},
issn = {01676423},
journal = {Science of Computer Programming},
keywords = {Operator precedence grammar,Parallel parser,Parallel parsing algorithms,Syntax analysis},
number = {P3},
pages = {195--226},
publisher = {Elsevier B.V.},
title = {{Parallel parsing made practical}},
url = {http://dx.doi.org/10.1016/j.scico.2015.09.002},
volume = {112},
year = {2015}
}
@article{Fowler2009a,
author = {Fowler, S and Paul, J},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Fowler, Paul - 2009 - Parallel Parsing The Earley and Packrat Algorithms.pdf:pdf},
title = {{Parallel Parsing: The Earley and Packrat Algorithms}},
url = {http://www.cs.berkeley.edu/{~}kubitron/courses/cs252-S09/projects/reports/project5{\_}report{\_}ver2.pdf{\%}5Cnpapers2://publication/uuid/C717AB02-7615-4F83-929F-D0F05DB82600},
year = {2009}
}
@article{Warth2008a,
abstract = {Packrat parsing offers several advantages over other parsing techniques, such as the guarantee of linear parse times while supporting backtracking and unlimited look-ahead. Unfortunately, the limited support for left recursion in packrat parser implementations makes them difficult to use for a large class of grammars (Java's, for example). This paper presents a modification to the memoization mechanism used by packrat parser implementations that makes it possible for them to support (even indirectly or mutually) left-recursive rules. While it is possible for a packrat parser with our modification to yield super-linear parse times for some left-recursive grammars, our experimentsshow that this is not the case for typical uses of left recursion. Copyright {\textcopyright} 2008 ACM.},
author = {Warth, Alessandro and Douglass, James R. and Millstein, Todd},
doi = {10.1145/1328408.1328424},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Warth, Douglass, Millstein - 2008 - Packrat parsers can support left recursion.pdf:pdf},
isbn = {9781595939777},
journal = {Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation},
keywords = {Left recursion,Packrat parsing},
number = {January},
pages = {103--110},
title = {{Packrat parsers can support left recursion}},
year = {2008}
}
@article{Redziejowski2018a,
abstract = {Parsing Expression Grammar (PEG) encodes a recursive-descent parser with limited backtracking. Its properties are useful in many applications, but it is not well understood as a language definition tool. In its appearance, PEG is almost identical to a grammar in the Extended Backus-Naur Form (EBNF), and one may expect it to define the same language. But, due to the limited backtracking, PEG may reject some strings defined by EBNF, which gives an impression of PEG being unpredictable. We note that for some grammars, the limited backtracking is "efficient", in the sense that it exhausts all possibilities. A PEG with efficient backtracking should therefore be easy to understand. There is no general algorithm to check if the grammar has efficient backtracking, but it can be often checked by inspection. The paper outlines an interactive tool to facilitate such inspection.},
author = {Redziejowski, Roman R.},
doi = {10.3233/FI-2018-1638},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Redziejowski - 2018 - Trying to Understand PEG.pdf:pdf},
issn = {01692968},
journal = {Fundamenta Informaticae},
number = {4},
pages = {463--475},
title = {{Trying to Understand PEG}},
volume = {157},
year = {2018}
}
@article{Galila,
author = {Galil, Zvi},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Galil - Unknown - Parallel Dynamic Programming Zvi Galil.pdf:pdf},
journal = {Computing},
pages = {1--18},
title = {{Parallel Dynamic Programming Zvi Galil}}
}
@article{Acar2016a,
abstract = {Increasing availability of multicore systems has led to greater focus on the design and implementation of languages for writing parallel programs. Such languages support various abstractions for parallelism, such as fork-join, async-finish, futures. While they may seem similar, these abstractions lead to different semantics, language design and implementation decisions, and can significantly impact the performance of end-user applications. In this paper, we consider the question of whether it would be possible to unify various paradigms of parallel computing. To this end, we propose a calculus, called dag calculus, that can encode fork-join, async-finish, and futures, and possibly others.We describe dag calculus and its semantics, establish translations from the aforementioned paradigms into dag calculus. These translations establish that dag calculus is sufficiently powerful for encoding programs written in prevailing paradigms of parallelism. We present concurrent algorithms and data structures for realizing dag calculus on multicore hardware and prove that the proposed techniques are consistent with the semantics. Finally, we present an implementation of the calculus and evaluate it empirically by comparing its performance to highly optimized code from prior work. The results show that the calculus is expressive and that it competes well with, and sometimes outperforms, the state of the art.},
author = {Acar, Umut A. and Chargu{\'{e}}raud, Arthur and Rainey, Mike and Sieczkowski, Filip},
doi = {10.1145/2951913.2951946},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Acar et al. - 2016 - Dag-calculus A calculus for parallel computation.pdf:pdf},
isbn = {9781450342193},
issn = {03621340},
journal = {ICFP 2016 - Proceedings of the 21st ACM SIGPLAN International Conference on Functional Programming},
keywords = {Calculus,Concurrent data structures,Experiments,Operational semantics,Parallelism,Proofs},
number = {Section 3},
pages = {18--32},
title = {{Dag-calculus: A calculus for parallel computation}},
year = {2016}
}
@article{Kuramitsu2015a,
abstract = {Packrat parsing is a linear-time implementation method of recursive descent parsers. The trick is a memoization mechanism, where all parsing results are memorized to avoid redundant parsing in cases of backtracking. An arising problem is extremely huge heap consumption in memoization, resulting in the fact that the cost of memoization is likely to outweigh its benefits. In many cases, developers need to make a difficult choice to abandon packrat parsing despite the possible exponential time parsing. Elastic packrat parsing is developed in order to avoid such a difficult choice. The heap consumption is upper-bounded since memorized results are stored on a sliding window buffer. In addition, the buffer capacity is adjusted by tracing each of nonterminal backtracking activities at runtime. Elastic packrat parsing is implemented in a part of our Nez parser. We demonstrate that the elastic packrat parsing achieves stable and robust performance against a variety of inputs with different backtracking activities.},
author = {Kuramitsu, Kimio},
doi = {10.2197/ipsjjip.23.505},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Kuramitsu - 2015 - Packrat parsing with elastic sliding window.pdf:pdf},
issn = {18826652},
journal = {Journal of Information Processing},
keywords = {Backtracking activity,Packrat parsing,Parser generators,Parsing expression grammars},
number = {4},
pages = {505--512},
title = {{Packrat parsing with elastic sliding window}},
volume = {23},
year = {2015}
}
@article{Mizushima2010a,
abstract = {Packrat parsing is a powerful parsing algorithm presented by Ford in 2002. Packrat parsers can handle complicated grammars and recursive structures in lexical elements more easily than the traditional LL(k) or LR(1) parsing algorithms. However, packrat parsers require O(n) space for memoization, where n is the length of the input. This space inefficiency makes packrat parsers impractical in some applications. In our earlier work, we had proposed a packrat parser generator that accepts grammars extended with cut operators, which enable the generated parsers to reduce the amount of storage required. Experiments showed that parsers generated from cut-inserted grammars can parse Java programs and subset XML files in bounded space. In this study, we propose methods to automatically insert cut operators into some practical grammars without changing the accepted languages. Our experimental evaluations indicated that using our methods, packrat parsers can handle some practical grammars including the Java grammar in mostly constant space without requiring any extra annotations. {\textcopyright} 2010 ACM.},
author = {Mizushima, Kota and Maeda, Atusi and Yamaguchi, Yoshinori},
doi = {10.1145/1806672.1806679},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Mizushima, Maeda, Yamaguchi - 2010 - Packrat parsers can handle practical grammars in mostly constant space.pdf:pdf},
isbn = {9781450300827},
journal = {ACM SIGPLAN/SIGSOFT Workshop on Program Analysis for Software Tools and Engineering},
keywords = {backtracking,cut operators,memoization,packrat parsing,parser generator,parsing expression grammars},
pages = {29--36},
title = {{Packrat parsers can handle practical grammars in mostly constant space}},
year = {2010}
}
@article{Ierusalimschy2009a,
abstract = {Current text patternmatching tools are based on regular expressions. However, pure regular expressions have proven too weak a formalism for the task: many interesting patterns either are difficult to describe or cannot be described by regular expressions. Moreover, the inherent nondeterminism of regular expressions does not fit the need to capture specific parts of a match. Motivated by these reasons, most scripting languages nowadays use patternmatching tools that extend the original regularexpression formalism with a set of ad hoc features, such as greedy repetitions, lazy repetitions, possessive repetitions, 'longestmatch rule,' lookahead, etc. These ad hoc extensions bring their own set of problems, such as lack of a formal foundation and complex implementations. In this paper, we propose the use of Parsing Expression Grammars (PEGs) as a basis for pattern matching. Following this proposal, we present LPEG, a patternmatching tool based on PEGs for the Lua scripting language. LPEG unifies the ease of use of patternmatching tools with the full expressive power of PEGs. Because of this expressive power, it can avoid the myriad of ad hoc constructions present in several current patternmatching tools. We also present a Parsing Machine that allows a small and efficient implementation of PEGs for pattern matching. {\textcopyright} 2008 John Wiley {\&} Sons, Ltd.},
author = {Ierusalimschy, Roberto},
doi = {10.1002/spe.892},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Ierusalimschy - 2009 - A text patternmatching tool based on parsing expression grammars.pdf:pdf},
issn = {00380644},
journal = {Software - Practice and Experience},
keywords = {Parsing expression grammars,Pattern matching,Scripting languages},
number = {3},
pages = {221--258},
title = {{A text patternmatching tool based on parsing expression grammars}},
volume = {39},
year = {2009}
}
@article{Grimm2006a,
abstract = {We explore how to make the benefits of modularity available for syntactic specifications and present Rats!, a parser generator for Java that supports easily extensible syntax. Our parser generator builds on recent research on parsing expression grammars (PEGs), which, by being closed under composition, prioritizing choices, supporting unlimited lookahead, and integrating lexing and parsing, offer an attractive alternative to context-free grammars. PEGs are implemented by so-called packrat parsers, which are recursive descent parsers that memoize all intermediate results (hence their name). Memoization ensures linear-time performance in the presence of unlimited lookahead, but also results in an essentially lazy, functional parsing technique. In this paper, we explore how to leverage PEGs and packrat parsers as the foundation for extensible syntax. In particular, we show how make packrat parsing more widely applicable by implementing this lazy, functional technique in a strict, imperative language, while also generating better performing parsers through aggressive optimizations. Next, we develop a module system for organizing, modifying, and composing large-scale syntactic specifications. Finally, we describe a new technique for managing (global) parsing state in functional parsers. Our experimental evaluation demonstrates that the resulting parser generator succeeds at providing extensible syntax. In particular, Rats! enables other grammar writers to realize real-world language extensions in little time and code, and it generates parsers that consistently outperform parsers created by two GLR parser generators. Copyright {\textcopyright} 2006 ACM.},
author = {Grimm, Robert},
doi = {10.1145/1133255.1133987},
file = {:home/blackgeorge/.local/share/data/Mendeley Ltd./Mendeley Desktop/Downloaded/Grimm - 2006 - Better extensibility through modular syntax.pdf:pdf},
isbn = {1595933204},
issn = {03621340},
journal = {Proceedings of the ACM SIGPLAN Conference on Programming Language Design and Implementation (PLDI)},
keywords = {Extensible syntax,Module system,Packrat parsing,Parser generator,Parsing expression grammar,Rats!},
pages = {38--51},
title = {{Better extensibility through modular syntax}},
volume = {2006},
year = {2006}
}
@inproceedings{Moore2000,
doi = {10.5555/974305.974338},
author = {Moore, Robert C.},
title = {Removing Left Recursion from Context-Free Grammars},
year = {2000},
publisher = {Association for Computational Linguistics},
address = {USA},
booktitle = {Proceedings of the 1st North American Chapter of the Association for Computational Linguistics Conference},
pages = {249–255},
numpages = {7},
location = {Seattle, Washington},
series = {NAACL 2000}
}
