\chapter{ Εισαγωγή }
\label{ch:intro}

Κάθε γλώσσα προγραμματισμού από τη φάση σχεδιασμού της έχει ακριβείς κανόνες που καθορίζουν τη συντακτική δομή των σωστά διατυπωμένων προγραμμάτων της. \cite{Aho2006}
Στη C, για παράδειγμα, ένα πρόγραμμα αποτελείται από συναρτήσεις, μια συνάρτηση από δηλώσεις και εντολές, μια εντολή από εκφράσεις, και ούτω καθ' εξής.
Πρακτικά όλες οι γλώσσες που χρησιμοποιούνται συχνά σήμερα, τόσο φυσικές γλώσσες όσο και γλώσσες μηχανής, βασίζονται στην έκφραση της πληροφορίας με γραμμικό τρόπο, 
όπως οι ακολουθίες συμβόλων  \cite{Ford2002a}.
Το κείμενο σε μία γραπτή γλώσσα συνήθως αναπαρίσταται ως μία  \textit{ συμβολοσειρά}, δηλαδή μια ακολουθία χαρακτήρων που προέρχονται από ένα τυποποιημένο σύνολο. 
Το πρώτο πράγμα που πρέπει να κάνει οποιαδήποτε εφαρμογή επεξεργασίας γλώσσας, 
είναι να μετατρέψει αυτές τις συμβολοσειρές σε πιο αφηρημένες δομές όπως λέξεις, φράσεις, προτάσεις, εκφράσεις ή εντολές.
Η διαδικασία που εξάγει τέτοια χρήσιμη δομημένη πληροφορία από γραμμικό κείμενο είναι γνωστή ως συντακτική ανάλυση ή parsing.

\section{ Ορισμός συντακτικού}

Προκειμένου να κατασκευάσουμε έναν συντακτικό αναλυτή (ή  parser) για μία γλώσσα, ή ακόμα και για να ορίσουμε τυπικά ποια είδη συμβολοσειρών έχουν νόημα σε αυτήν, πρέπει να έχουμε έναν τρόπο να για να εκφράσουμε και να κατανοήσουμε τη συντακτική δομή της.
Για το σκοπό αυτό συνήθως χρησιμοποιούμε κάποια  \textit{ γραμματική}, που είναι μία συμπαγής αναπαράστησαση της δομής μίας γλωσσας, εκφρασμένη σε κάποια άλλη (ιδανικά μικρή και απλή) γλώσσα.
Η γλώσσα της οποίας της δομή προσπαθούμε να αναπαραστήσουμε είναι η  \textit{ γλώσσα αντικείμενο}, ενώ η γλώσσα στην οποία \textit{ εκφράζεται} η συντακτική δομή ονομάζεται  \textit{γραμματική ορισμού γλώσσας}. 

Ο πιο συνηθισμένος τύπος γραμματικής σήμερα, είναι οι \textit{γραμμτικές χωρίς συμφραζόμενα ( context-free grammars - CFG)}, εκφρασμένες σε  Backus-Naur Form (BNF). 
Μία γραμματική χωρίς συμφραζόμενα ουσιαστικά εκφράζει ένα σύνολο αμοιβαίως αναδρομικών κανόνων, οι οποίες περιγράφουν πώς μπορουυν να γραφτούν οι συμβολοσειρές που περιγράφονται στη γλώσσα.
Κάθε κανόνας ή \textit{ παραγωγή}  σε μία  CFG καθορίζει έναν τρόπο με τον οποίο μία συντακτική μεταβλητή ή  \textit{ μη τερματικό} μπορεί να αντικατασταθεί σε μία συμβολοσειρά. 
Ένα μη τερματικό μπορεί να αντικατασταθείξλ σε μία συμβολοσειρά που μπορεί να περιέχει άλλα μη τερματικά, τα οποία θα αντικατασταθούν με τη σειρά τους, ώσπου να μην υπάρχουν άλλα.
Επειδή υπάρχουν πολλοί τρόποι για να αντικατασταθεί ένα μη τερματικό, η γραμματική μπορεί να εκφράσει ένα άπειρο σύνολο καλώς ορισμένων συμβολοσειρών.
Η συντακτική ανάλυση μιας συμβολοσειράς, της οποίας η σύνταξη περιγράφεται από μία  CFG, περιλαμβάνει την ανάποδη διαδικασία: 
να καθοριστεί από μία πλήρως ανεπτυγμένη συμβολοσειρά, η οποία περιέχει μόνο ατομικούς χαρακτήρες ή  \textit{ τερματικά}, ποια ακολουθία (ή ακολουθίες βημάτων) αντικατάστασης, αν υπάρχουν, οδηγούν στην παραγωγή της συμβολοσειράς.
Αυτή η εργασία περιπλέκεται καθώς οι  CFGs  συνήθως περιέχουν αμφισημίες:
σε  \textit{τοπικό επίπεδο}, όπου η σωστή ερμηνεία ενός τμήματος της συμβολοσειράς μπορεί να καθοριστεί μόνο από τα συμφραζόμενα; 
σε \textit{καθολικό επίπεδο}, όπου ολόκληρη η συμβολοσειρά μπορεί να έχει πολλαπλές έγκυρες συντακτικές ερμηνείες.

\section{ Parsing Expression Grammars}
 Η θεωρία και η πράξη της συντακτικής ανάλυσης βασίζεται σε \textit{ παραγωγικά ( generative)} συστήματα, όπως οι κανονικές εκφράσεις και οι γραμματικές χωρίς συμφραζόμενα, στα οποία η γλώσσα ορίζεται τυπικά μέσα από κανόνες οι οποίοι όταν εφαρμοστούν αναδρομικά παράγουν συμβολοσειρές της γλώσσας.
Αντίθετα, σε ένα \textit{ αναγνωριστικό σύστημα ( recognition-based system)} η γλώσσα ορίζεται μέσα από κανόνες ή κατηγορήματα που αποφασίζουν εάν η δοθείσα συμβολοσειρά ανήκει στη γλώσσα \cite{Ford2004}.
Οι απλές γλώσσες μπορούν να εκφραστούν εξίσου εύκολα και στα δύο συστήματα.
 Για παράδειγμα, το $\{ s \in \mathbf{a}^* | s = {(\mathbf{a}\mathbf{a})}^n\}$ είναι ένας παραγωγικός ορισμός μιας γλώσσας με ένα μόνο γράμμα στο λεξιλόγιό της, της οποίας οι συμβολοσειρές 
 κατασκευάζονται συνενώνοντας ζεύγη από $ \mathbf{a}$.
 Από την άλλη, το $\{ s \in \mathbf{a}^* | (\lvert s \rvert mod2=0)\}$, είναι ένας αναγνωριστικός ορισμός, όπου μία συμβολοσειρά από  $\mathbf{a}$'s γίνεται αποδεκτή μόνο αν το μήκος της είναι άρτιο.
 
  Αν και το παραγωγικό μοντέλο χρησιμοποιείται ευρύτατα στη θεωρία γλωσσών, οι πιο πολλές πρακτικές γλωσσικές εφαρμογές περιλαμβάνουν την αναγνώριση και τη δομική ανάλυση συμβολοσειρών. 
Εμείς θα χρησιμοποιήσουμε το αναγνωριστικό μοντέλο για τη σύνταξη της γλώσσας, η οποία θα περιγράφεται από τις  \textit{Parsing Expression Grammars (PEGs)}. Αυτές μοιάζουν με τις γραμματικές χωρίς συμφραζόμενα με την προσθήκη χαρακτηριστικών από τις κανονικές εκφράσεις, όμοια με την  Extended BNF σημειογραφία.

\section{ Packrat Parsing}
Με βάση τις Parsing Expression Grammars και το αναγνωριστικό σχήμα, ο απλούστερος τρόπος να αναλυθεί (συντακτικά) μία συμβολοσειρά έιναι μέσω ενός αναδρομικού καθοδικού συντακτικού αναλυτή, με δυνατόττηα για οπισθαναχώρηση ( backtracking). 
Ωστόσο, σε πολλές  PEGs  ένας συνήθης καθοδικός αναλυτής μπορεί να κάνει εκθετικό χρόνο για να αναγνωρίσει μία συμβολοσειρά στην είσοδο. 
Και αυτό διότι η οπισθαναώρηση μπορεί να οδηγήσει σε πλεονάζοντες υπολογισμούς ενδιάμεσων αποτελεσμάτων.
Αν, όμως, χρησιμοποιηθεί \textit{ υπομνηματισμός ( memoisation)} για να αποφευχθούν τέτοιοι πλεονασμοί, μία  PEG  μπορεί να αναλυθεί σε γραμμικό χρόνο με το μήκος της εισόδου.
Ένας τέτοιος συντακτικός αναλυτής ονομάζεται \textit{Packrat Parser}.

\section{ Αυτόματη παραγωγή των  Packrat Parsers}
Αν και το  packrat parsing είναι εύκολο να υλοποιηθεί με το χέρι, θα ήταν ακόμη καλύτερο να μπορούσαμε να κατασκευάσουμε τέτοιους συντακτικούς αναλυτές με αυτόματο τρόπο, όμοια με το  YACC  στον κόσμο της C. 
Ένας \textit{γεννήτορας συντακτιών αναλυτών (parser generator)} παίρνει ως είσοδο μία τυπική περιγραφή της γραμματικής και "γεννάει" τον αντίστοιχο συντακτικό αναλυτή  σε  C++.
Η περιγραφή που δέχεται ο δικός μας γεννήτορας βασίζεται στη σημειογραφία των  PEGs. 
Τέλος, παρέχει και τη δυνατότητα να επιστραφεί το συντακτικό δέντρο μετά την ανάλυση, ενώ επεκτείνεται εύκολα ώστε να κρατήσει και άλλες σημασιολογικές τιμές.
Οι βασικές ιδέες για την υλοποίησή του πηγάζουν από πρότερη δουλειά που έχει γίνει σε  Java % TODO: \cite{fowler} \cite{lgi}.

\section{  Παράλληλο Packrat Parsing}
Αφού  υλοποιήσουμε έναν  packrat parser generator σε C++, η βασική συνεισφορά που θέλουμε να κάνουμε στα πλαίσια της διπλωματικής, είναι να εξετάσουμε κατά πόσο και πώς ένας σειριακός packrat parser μπορεί να παραλληλοποιθεί ώστε να τρέχει αποδοτικότερα σε ένα πολυπύρηνο σύστημα με αρχιτεκτονική κοινής μνήμης.
Η πρώτη προσέγγιση που έχει δοκιμαστεί (cite fowler) είναι να χωρίζεται η είσοδος σε κομμάτια και να αναλαμβάνει ένα νήμα να υπολογίσει τα κελιά του συντακτικού αναλυτή που αφορούν το συγκεκριμένο κομμάτι. (% TODO: add more about seith fowler)
H  πρώτη δική μας προσέγγιση ήταν να αντί για υπομνηματισμό, να χρησιμοποιήσουμε δυναμικό προγραμματισμό, τον οποίο επειτα δοκιμάσαμε να παραλληλοποιήσουμε.
Ακολούθως, εφαρμόσαμε παραλληλοποίηση στην πράξη της \textit{ επιλογής ( choice)} των  PEGs % TODO: add more about pht
Τέλος, αφού υλοποιήσαμε το  Elastic % TODO: 

\section{  Η δομή της εργασίας}


